---
title: Concurrence
description: Gestion de transactions et de la concurrence
date: 24/03/2025
---

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> CAE </PathViewerItem>
    <PathViewerItem to="/iteration3"> It√©ration 3 </PathViewerItem>
    <PathViewerItem selected> Gestion de transactions et de la concurrence </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Comment g√©rer des transactions dans Spring Boot ? </InternalPageMenuItem>
  <InternalPageMenuItem> Pourquoi g√©rer la concurrence ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment g√©rer la concurrence ? </InternalPageMenuItem>
  <InternalPageMenuItem> Optimistic Locking dans Spring Boot </InternalPageMenuItem>
  <InternalPageMenuItem> Pessimistic Locking dans Spring Boot </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Comment g√©rer des transactions dans Spring Boot ? </InternalPageTitle>

## Introduction

Les transactions sont un moyen de regrouper plusieurs op√©rations en une seule unit√© logique. Cela garantit que toutes les op√©rations sont ex√©cut√©es de mani√®re atomique, c'est-√†-dire que toutes les op√©rations sont ex√©cut√©es ou aucune op√©ration n'est ex√©cut√©e.

Avec Spring Boot, vous pouvez g√©rer les transactions en utilisant l'annotation **`@Transactional`**. Cette annotation permet de d√©finir une m√©thode comme transactionnelle. Cela signifie que toutes les op√©rations sur la base de donn√©es effectu√©es dans cette m√©thode seront regroup√©es en une seule transaction.

Par exemple, si vous souhaitez ajouter une adresse √† un utilisateur, vous devez ajouter l'adresse et mettre √† jour l'utilisateur en m√™me temps. Si l'une des op√©rations √©choue, vous ne voulez pas que l'autre op√©ration soit ex√©cut√©e. Les transactions garantissent que les deux op√©rations sont ex√©cut√©es ensemble.

Si une exception est lev√©e dans une m√©thode annot√©e avec **`@Transactional`**, la transaction est automatiquement annul√©e et les op√©rations effectu√©es dans cette transaction sont annul√©es. Cela correspond √† un **`rollback`** au niveau de la base de donn√©es.
Cela garantit que les donn√©es restent coh√©rentes. Si tout se passe bien, la transaction est valid√©e et les op√©rations sont confirm√©es. Cela correspond √† un **`commit`** au niveau de la base de donn√©es. 

Les transactions ne r√®glent pas les probl√®mes de concurrence que nous verrons plus tard. N√©anmoins, si les transactions sont coupl√©es √† la gestion de la concurrence (optimistic ou pessimistic locking trait√©s apr√®s la gestion des transactions), elles permettent de g√©rer les conflits de mani√®re plus robuste.

## Bases pour les transactions

Voici un exemple de transaction en Java avec Spring Boot, lorsque nous avons un repository pour les utilisateurs et un repository pour les adresses.

Voici les entit√©s :

```java {} showLineNumbers
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "address_id", referencedColumnName = "id")
    private Address address;

    // Getters et setters
}

@Entity
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true) // Emp√™che les doublons d'adresses
    private String street;

    private String city;

    private String postalCode;

    // Getters et setters
}
```


Voici les repositories :

```java {} showLineNumbers
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
```

Voici les DTO pour les requ√™tes :

```java {} showLineNumbers
public class UserDTO {
    private String name;
    private AddressDTO address;

    // Getters et setters
}

public class AddressDTO {
    private String street;
    private String city;
    private String postalCode;

    // Getters et setters
}
```

Voici le contr√¥leur :

```java {} showLineNumbers
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping
    public User addUserWithAddress(@RequestBody UserDTO userDTO) {
        return userService.addUserWithAddress(userDTO);
    }
}
```

Voici l'exception que nous souhaitons lancer pour une adresse d√©j√† existante :

```Java
public class AddressAlreadyExistsException extends RuntimeException {
    public AddressAlreadyExistsException(String message) {
        super(message);
    }
}
```

Voici un service pour ajouter une adresse et un utilisateur :

```java {12} showLineNumbers
@Service
public class UserService {

    private final UserRepository userRepository;
    private final AddressRepository addressRepository;

    public UserService(UserRepository userRepository, AddressRepository addressRepository) {
        this.userRepository = userRepository;
        this.addressRepository = addressRepository;
    }

    @Transactional
    public User addUserWithAddress(UserDTO userDTO) {
        // V√©rifier si l'adresse existe d√©j√†
        Optional<Address> existingAddress = addressRepository.findByStreetAndCityAndPostalCode(
                userDTO.getAddress().getStreet(),
                userDTO.getAddress().getCity(),
                userDTO.getAddress().getPostalCode()
        );

        if (existingAddress.isPresent()) {
            throw new AddressAlreadyExistsException("L'adresse existe d√©j√† !");
        }

        // Sauvegarder l'adresse
        Address address = new Address();
        address.setStreet(userDTO.getAddress().getStreet());
        address.setCity(userDTO.getAddress().getCity());
        address.setPostalCode(userDTO.getAddress().getPostalCode());
        addressRepository.save(address);

        // Sauvegarder l'utilisateur
        User user = new User();
        user.setName(userDTO.getName());
        user.setAddress(address);
        return userRepository.save(user); // Retourner l'utilisateur sauvegard√©
    }
}
```

> Ici la gestion des transactions est assur√©e par l'annotation **`@Transactional`** sur la m√©thode **`addUserWithAddress`**. Cela signifie que toutes les op√©rations effectu√©es dans cette m√©thode seront regroup√©es en une seule transaction. Cela garantit que toutes les op√©rations sont ex√©cut√©es de mani√®re atomique, c'est-√†-dire que toutes les op√©rations sont ex√©cut√©es ou aucune op√©ration n'est ex√©cut√©e.

üí≠ Peux-tu imaginer une autre raison pour que JPA √©choue √† sauvegarder l'adresse ?  
Normalement, JPA ne devrait pas √©chouer √† sauvegarder l'adresse, car normalement, dans le contr√¥leur, on est cens√© valider tous les param√®tres avant d'appeler le service.  
Une fois l'adresse sauvegard√©e, on pourrait imaginer que l'on ne peut pas sauvegarder l'utilisateur. Par exemple, si l'utilisateur a d√©j√† √©t√© sauvegard√©, on ne peut pas le sauvegarder √† nouveau.  
L'avantage de la transaction est que si l'une des op√©rations √©choue, l'autre op√©ration ne sera pas ex√©cut√©e. Cela garantit que les donn√©es restent coh√©rentes.  
Bien s√ªr, pour rendre le code plus robuste et clair, il faudrait aussi v√©rifier si l'utilisateur existe d√©j√† avant de le sauvegarder.

üí≠ Est-ce que les transactions sont suffisantes dans cet exemple pour se prot√©ger contre les acc√®s concurrents ?  
Si deux transactions distinctes tentent de sauvegarder la m√™me adresse ou le m√™me utilisateur en m√™me temps, il pourrait y avoir des conflits ou des incoh√©rences.  
Cependant, l'optimistic ou le pessimistic locking (que nous verrons plus tard) n'est pas n√©cessaire ici car :
- La m√©thode **`save`** de JPA garantit que l'adresse ne sera pas dupliqu√©e si une contrainte d'unicit√© est d√©finie sur la colonne street (comme dans votre entit√© **`Address`** avec **`@Column(unique = true)`**).
- Si deux transactions tentent de sauvegarder la m√™me adresse en m√™me temps, la base de donn√©es l√®vera une exception (par exemple, une **`ConstraintViolationException`**). La deuxi√®me transaction sera annul√©e, garantissant que l'adresse n'est pas dupliqu√©e.

Et finalement, voici le gestionnaire global d'exceptions pour l'exception **`AddressAlreadyExistsException`** :

```java {} showLineNumbers
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AddressAlreadyExistsException.class)
    public void handleAddressAlreadyExistsException(AddressAlreadyExistsException ex) {
        throw new ResponseStatusException(HttpStatus.CONFLICT, ex.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public void handleGenericException(Exception ex) {
        throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Une erreur est survenue : " + ex.getMessage());
    }
}
```

Ici, le gestionnaire global d'exceptions renvoie une r√©ponse **`409 Conflict`** au client en cas d'exception **`AddressAlreadyExistsException`**. Cela signifie que si l'adresse existe d√©j√†, le client recevra une r√©ponse **`409 Conflict`**.

## Exemple concret

Veuillez mettre √† jour votre projet GitLab contenant la gestion des Pizzas pour ajouter la gestion des transactions.

Il suffit de rajouter l'annotation **`@Transactional`** sur les m√©thodes de service qui effectuent des op√©rations de mise √† jour sur la base de donn√©es et qui d√©pendent du succ√®s d'autres op√©rations.

Par exemple, au niveau de l'API de gestion de pizzas, lorsque nous ajoutons, ou effa√ßons des pizzas, nous faisons des op√©rations au niveau d'Azure Storage pour stocker ou effacer les images des pizzas.  
Si ces op√©rations √©chouent, nous ne voulons pas que les op√©rations de mise √† jour de la base de donn√©es soient ex√©cut√©es.  
Veuillez donc mettre √† jour le service de gestion des pizzas nomm√© **`services/PizzaService`**.

```java {79,133,171} showLineNumbers
package be.vinci.ipl.cae.demo.services;

import be.vinci.ipl.cae.demo.models.dtos.NewPizza;
import be.vinci.ipl.cae.demo.models.entities.Pizza;
import be.vinci.ipl.cae.demo.repositories.PizzaRepository;
import com.azure.storage.blob.BlobClientBuilder;
import com.azure.storage.blob.models.BlobHttpHeaders;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

/**
 * Pizza service.
 */
@Service
public class PizzaService {

  private final PizzaRepository pizzaRepository;
  private final String blobServiceEndpoint;
  private final String sasToken;
  private final String containerName;

  /**
   * Constructor.
   *
   * @param pizzaRepository the pizza repository
   */
  public PizzaService(PizzaRepository pizzaRepository,
      @Value("${azure.blob.service-endpoint}") String blobServiceEndpoint,
      @Value("${azure.blob.sas-token}") String sasToken,
      @Value("${azure.blob.container-name}") String containerName) {
    this.pizzaRepository = pizzaRepository;
    this.blobServiceEndpoint = blobServiceEndpoint;
    this.sasToken = sasToken;
    this.containerName = containerName;
  }

  /**
   * Read all pizzas.
   *
   * @param order if order contains "title" the pizzas will be ordered by title in ascending order
   *              if order contains "-title" the pizzas will be ordered by title in descending
   *              order.
   * @return the pizzas
   */
  public Iterable<Pizza> readAllPizzas(String order) {
    if (order == null || !order.contains("title")) {
      return pizzaRepository.findAll();
    }

    if (order.contains("-")) {
      return pizzaRepository.findAllByOrderByTitleDesc();
    }
    return pizzaRepository.findAllByOrderByTitleAsc();
  }

  /**
   * Read a pizza by its id.
   *
   * @param id the id
   * @return the pizza
   */
  public Pizza readPizzaById(Long id) {
    return pizzaRepository.findById(id).orElse(null);
  }

  /**
   * Create a pizza.
   *
   * @param newPizza the new pizza
   * @param image    the image
   * @return the pizza
   */
  @Transactional
  public Pizza createPizza(NewPizza newPizza, MultipartFile image) {
    Pizza pizza = new Pizza();
    pizza.setTitle(newPizza.getTitle());
    pizza.setContent(newPizza.getContent());

    if (image != null && !image.isEmpty()) {
      String blobUrl = uploadImageToBlob(image);
      pizza.setImageLocation(blobUrl);
    }

    return pizzaRepository.save(pizza);
  }

  /**
   * Upload an image to a blob on Azure storage with a generated UUID as filename. The image is
   * uploaded to the "images" folder. The original filename is stored in the metadata.
   *
   * @param image
   * @return the blob url
   * @throws IOException
   */
  private String uploadImageToBlob(MultipartFile image) {
    String imageUUID = UUID.randomUUID().toString();
    Map<String, String> metadata = new HashMap<>();

    String blobName = imageUUID;

    metadata.put("originalFileName", image.getOriginalFilename());
    BlobClientBuilder blobClientBuilder = new BlobClientBuilder()
        .endpoint(blobServiceEndpoint)
        .sasToken(sasToken)
        .containerName(containerName)
        .blobName(blobName);

    try {
      blobClientBuilder.buildClient().upload(image.getInputStream(), image.getSize(), true);
      blobClientBuilder.buildClient().setMetadata(metadata);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
    blobClientBuilder.buildClient()
        .setHttpHeaders(new BlobHttpHeaders().setContentType(image.getContentType()));

    return blobClientBuilder.buildClient().getBlobUrl();
  }


  /**
   * Delete a pizza by its id.
   *
   * @param id the id
   * @return the pizza
   */
  @Transactional
  public Pizza deletePizza(Long id) {
    Pizza pizza = pizzaRepository.findById(id).orElse(null);
    if (pizza != null) {
      if (pizza.getImageLocation() != null) {
        deleteImageFromBlob(pizza.getImageLocation());
      }
      pizzaRepository.delete(pizza);
    }
    return pizza;
  }

  /**
   * Delete an image from the blob storage.
   *
   * @param imageLocation the image location
   */
  private void deleteImageFromBlob(String imageLocation) {
    if (imageLocation != null && !imageLocation.isEmpty() && imageLocation.contains(
        blobServiceEndpoint)) {
      String blobName = imageLocation.substring(imageLocation.lastIndexOf("/") + 1);
      BlobClientBuilder blobClientBuilder = new BlobClientBuilder()
          .endpoint(blobServiceEndpoint)
          .sasToken(sasToken)
          .containerName(containerName)
          .blobName(blobName);

      blobClientBuilder.buildClient().delete();
    }
  }

  /**
   * Update a pizza.
   *
   * @param id       the id
   * @param newPizza the new pizza
   * @return the pizza
   */
  @Transactional
  public Pizza updatePizza(Long id, NewPizza newPizza) {
    Pizza pizza = pizzaRepository.findById(id).orElse(null);
    if (pizza == null) {
      return null;
    }

    if (newPizza.getTitle() != null) {
      pizza.setTitle(newPizza.getTitle());
    }
    if (newPizza.getContent() != null) {
      pizza.setContent(newPizza.getContent());
    }

    return pizzaRepository.save(pizza);
  }

}
```

Gr√¢ce √† ces ajouts minuscules, si par exemple l'op√©ration de sauvegarde de l'image √©choue, l'op√©ration de sauvegarde de la pizza ne sera pas ex√©cut√©e. En effet, si la fonction **`uploadImageToBlob`** l√®ve une exception, la transaction sera annul√©e et la pizza ne sera pas sauvegard√©e.  
Nous n'avons pas r√©ellement besoin de transaction pour cette op√©ration, car la sauvegarde de la pizza ne se fait que si l'op√©ration de sauvegarde de l'image r√©ussit. N√©anmoins, nous pouvons facilement imaginer un sc√©nario o√π la transaction serait n√©cessaire, par exemple :
- si nous devions sauvegarder la pizza avant de sauvegarder l'image.
- si nous devions d'abord sauvegarder les ingr√©dients de la pizza avant de sauvegarder la pizza, puis d'uploader l'image.

Dans ces cas, les transactions garantissent que toutes les op√©rations sur la DB sont ex√©cut√©es ou aucune op√©ration n'est ex√©cut√©e.

## En savoir plus

Si vous souhaitez en savoir plus sur les transactions avec Spring Boot, vous pouvez consulter cet article : https://docs.spring.io/spring-framework/reference/data-access/transaction.html

# <InternalPageTitle> Pourquoi g√©rer la concurrence ? </InternalPageTitle>

La concurrence est un sujet important en informatique. En effet, de nombreux probl√®mes peuvent survenir si la concurrence n'est pas g√©r√©e correctement. Par exemple, si deux processus essaient de modifier la m√™me donn√©e en m√™me temps, il peut y avoir des probl√®mes de coh√©rence des donn√©es.

Prenons l'exemple d'une application o√π l'on g√®re un stock de produits. Si deux utilisateurs essaient de modifier la quantit√© d'un produit en m√™me temps, il peut y avoir des probl√®mes de coh√©rence des donn√©es. Par exemple, si un utilisateur essaie d'ajouter 5 unit√©s √† la quantit√© d'un produit, et qu'un autre utilisateur essaie de retirer 3 unit√©s du m√™me produit en m√™me temps, il peut y avoir des probl√®mes de coh√©rence des donn√©es.

NB : La concurrence pourrait entra√Æner des probl√®mes de performance si elle n'est pas g√©r√©e correctement. Par exemple, si plusieurs processus essaient d'acc√©der √† la m√™me ressource en m√™me temps, il peut y avoir des probl√®mes de latence et de ralentissement. N√©anmoins, nous ne devons g√©n√©ralement pas g√©rer ce type de probl√®me car cela est automatiquement trait√© par les frameworks que nous utilisons. En effet, en cas de multiples requ√™tes sur une m√™me ressource, le framework Spring Boot g√®re cela en cr√©ant un pool de threads pour traiter les requ√™tes. Comment √ßa fonctionne ?  
Lorsqu'une requ√™te HTTP arrive, un thread est extrait du pool pour traiter cette requ√™te.  
Une fois la requ√™te trait√©e, le thread est remis dans le pool pour √™tre r√©utilis√©.  
Cela permet de limiter le nombre de threads actifs et d'√©viter de cr√©er un nouveau thread pour chaque requ√™te, ce qui serait co√ªteux en termes de performances.

# <InternalPageTitle> Comment g√©rer la concurrence ? </InternalPageTitle>

## Introduction

Il existe plusieurs fa√ßons de g√©rer la concurrence en informatique. Voici quelques-unes des techniques les plus courantes :
- **Optimistic Locking** : Cette technique consiste √† v√©rifier si la donn√©e a √©t√© modifi√©e par un autre processus avant de la modifier. Si la donn√©e a √©t√© modifi√©e, une exception est lev√©e et le processus doit g√©rer cette exception.
- **Pessimistic Locking** : Cette technique consiste √† verrouiller la donn√©e avant de la modifier. Cela garantit qu'aucun autre processus ne peut modifier la donn√©e tant que le verrou n'est pas lib√©r√©.
- **Transactions** : Comme vu pr√©c√©demment, les transactions sont un moyen de regrouper plusieurs op√©rations sur une base de donn√©es en une seule unit√© logique. Cela garantit que toutes les op√©rations sont ex√©cut√©es de mani√®re atomique, c'est-√†-dire que toutes les op√©rations sont ex√©cut√©es ou aucune op√©ration n'est ex√©cut√©e. Les transactions sont particuli√®rement utiles pour garantir la coh√©rence des donn√©es dans des sc√©narios de concurrence, sans pour autant r√©gler les probl√®mes de concurrence en eux-m√™mes.
- **Verrous distribu√©s** : Les verrous distribu√©s peuvent √™tre utilis√©s pour coordonner l'acc√®s √† une ressource partag√©e entre plusieurs processus. Redis peut √™tre utilis√© pour ce genre d'applications. Des verrous peuvent √™tre utilis√©s pour garantir que seuls un certain nombre de processus peuvent acc√©der √† la ressource en m√™me temps. Cela est particuli√®rement utile dans des architectures distribu√©es, type microservices, o√π plusieurs instances doivent g√©rer une ressource partag√©e. Nous n'aborderons pas ce sujet dans ce cours, car notre application n'est pas distribu√©e.
- **File de messages** : Une file de messages (comme RabbitMQ ou Kafka) peut √™tre utilis√©e pour g√©rer la concurrence. Les messages sont envoy√©s √† une file, puis trait√©s par un ou plusieurs consommateurs. Cela permet de g√©rer la concurrence en s√©parant la production de la consommation de messages. Ce type de solution est particuli√®rement utile dans des architectures distribu√©es, o√π plusieurs instances doivent traiter des messages en parall√®le. Nous n'aborderons pas ce sujet dans ce cours.

# <InternalPageTitle> Optimistic Locking dans Spring Boot </InternalPageTitle>


## Introduction

L'optimistic locking repose sur l'id√©e que les conflits sont rares. Avant de mettre √† jour une donn√©e, on v√©rifie si elle a √©t√© modifi√©e par un autre processus en utilisant un champ de version.

L'optimistic locking est id√©al pour les sc√©narios o√π les conflits sont peu fr√©quents, comme la mise √† jour d'un nom de produit ou la mise √† jour d'une quantit√© en stock, lorsque le stock est modifiable par un nombre limit√© d'utilisateurs.

L'int√©r√™t de l'optimistic locking est qu'il n'y a pas de verrouillage de la ressource, ce qui permet √† plusieurs processus de lire la ressource en m√™me temps. Cela am√©liore les performances de l'application. Cependant, si un conflit survient, il faut g√©rer l'exception lev√©e par la base de donn√©es.

## Bases pour l'optimistic locking

Voici un exemple d'optimistic locking en Java avec JPA :

```java {11,19,29} showLineNumbers
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private int quantity;

    @Version
    private long version; // Champ utilis√© pour l'optimistic locking

    // Getters et setters
}

// Partie du service pour mettre √† jour le stock d'un produit

@Transactional
public void updateStock(Long productId, int quantityToRemove) {
    Product product = productRepository.findById(productId)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));
    
    if(product.getQuantity() < quantityToRemove) {
        throw new RuntimeException("Stock insuffisant");
    }

    product.setQuantity(product.getQuantity() - quantityToRemove);
    productRepository.save(product); // V√©rifie automatiquement la version
}
```

Dans cet exemple, le champ **`version`** est utilis√© pour l'optimistic locking. Lorsque la m√©thode `save` est appel√©e, JPA v√©rifie automatiquement si la version de l'entit√© en base de donn√©es correspond √† la version de l'entit√© en m√©moire. Si ce n'est pas le cas, une exception **`OptimisticLockException`** est lev√©e.

**`@Transactional`** : Cette annotation permet de d√©finir une m√©thode comme transactionnelle. Cela signifie que toutes les op√©rations effectu√©es dans cette m√©thode seront regroup√©es en une seule transaction. Ici, comme il n'y a qu'une seule op√©ration (la mise √† jour du stock), l'annotation **`@Transactional`** n'est pas strictement n√©cessaire, mais elle est recommand√©e pour des raisons de clart√©.  
En effet, si vous ajoutez d'autres op√©rations de modification dans cette m√©thode, elles seront automatiquement incluses dans la transaction.

Ici l'on v√©rifie la version de l'entit√© en base de donn√©es au moment de la sauvegarde. Cela est suffisant pour g√©rer les conflits dans le cadre d'une op√©ration transactionnelle unique, si l'on imaginait que deux utilisateurs essaient de modifier la quantit√© d'un produit en m√™me temps. 

> Attention : Le code donn√© pour l'optimistic locking dans l'exemple ci-dessus fonctionne bien dans le cadre d'une op√©ration transactionnelle unique, o√π la version est v√©rifi√©e au moment de l'ex√©cution de la m√©thode **`updateStock`**. Cependant, dans le contexte d'une API RESTful, o√π les appels sont effectu√©s par des clients distincts (par exemple, deux requ√™tes HTTP s√©par√©es), ce code ne couvre pas le cas o√π la version doit √™tre v√©rifi√©e entre deux requ√™tes clientes, lorsqu'il y a une op√©ration de lecture suivie d'une op√©ration de mise √† jour. Nous verrons comment g√©rer ce cas dans la section suivante.

## Exemple concret

Veuillez mettre √† jour votre projet GitLab contenant la gestion des Pizzas pour ajouter l'optimistic locking.

üí≠ Quelle serait l'op√©ration la plus √©vidente qui pourrait √™tre sujet √† des probl√®mes de concurrence ?  
L'op√©ration la plus √©vidente qui pourrait √™tre sujette √† des probl√®mes de concurrence est l'op√©ration de mise √† jour d'une pizza. En effet, si deux utilisateurs essaient de modifier la m√™me pizza en m√™me temps, il peut y avoir des probl√®mes de coh√©rence des donn√©es. Par exemple, si un utilisateur essaie de modifier le titre d'une pizza, et qu'un autre utilisateur essaie de modifier la description de la m√™me pizza en m√™me temps, il peut y avoir des probl√®mes de coh√©rence des donn√©es.

Pour ajouter l'optimistic locking √† notre application, nous devons ajouter un champ de version √† l'entit√© **`Pizza`** et utiliser cet attribut pour g√©rer les conflits de version lors de la mise √† jour d'une pizza.

Veuillez donc mettre √† jour l'entit√© **`Pizza`** pour ajouter un champ de version :

```java {20} showLineNumbers
@Entity
@Table(name = "pizzas")
@Data
@NoArgsConstructor
public class Pizza {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(nullable = false)
  private String title;

  @Column(nullable = false)
  private String content;

  @Column(nullable = true)
  private String imageLocation;

  @Version
  private Long version;
}
```

A l'aide du client HTTP d'IntelliJ, veuillez ajouter une pizza en ex√©cutant la requ√™te de cr√©ation de pizza contenant une image contenue dans le fichier **`/tests/java/pizzas.http`**.

Puis, via l'onglet **`Database`** d'IntelliJ, veuillez vous connecter √† votre DB local et v√©rifier que la pizza a bien √©t√© ajout√©e.  
Vous devriez observer que la table **`Pizza`** de votre DB contient une nouvelle entr√©e avec un champ **`version`** initialis√© √† **`0`**.

A chaque op√©ration de mise √† jour d'une pizza, le champ **`version`** sera automatiquement incr√©ment√© par JPA.

Veuillez ex√©cuter la requ√™te de mise √† jour d'une pizza contenue dans le fichier **`/tests/java/pizzas.http`**.  
Vous devriez observer que la version de la pizza a √©t√© incr√©ment√©e dans la DB, passant de **`0`** √† **`1`**.

Il est difficile de simuler un conflit de version avec le client HTTP d'IntelliJ, car les requ√™tes sont ex√©cut√©es de mani√®re s√©quentielle.  
Pour ce cours, nous ne simulerons pas de conflit de version, mais vous pouvez imaginer que si deux utilisateurs tentent de modifier la m√™me pizza en m√™me temps, il peut y avoir des probl√®mes de coh√©rence des donn√©es.  
Dans ce cas, voici le code d√©j√† existant de **`PizzaService`** qui va soulever une exception **`OptimisticLockException`** si la version de la pizza en m√©moire ne correspond pas √† la version de la pizza en base de donn√©es :

```java {3,15} showLineNumbers
@Transactional
  public Pizza updatePizza(Long id, NewPizza newPizza) {
    Pizza pizza = pizzaRepository.findById(id).orElse(null);
    if (pizza == null) {
      return null;
    }

    if (newPizza.getTitle() != null) {
      pizza.setTitle(newPizza.getTitle());
    }
    if (newPizza.getContent() != null) {
      pizza.setContent(newPizza.getContent());
    }

    return pizzaRepository.save(pizza);
  }
```

En effet, lors du **`save`** de la pizza, JPA v√©rifie automatiquement si la version de la pizza en m√©moire (retourn√©e par **`pizzaRepository.findById(id).orElse(null)`**) correspond √† la version de la pizza en base de donn√©es. Si ce n'est pas le cas, une exception **`OptimisticLockException`** est lev√©e car √ßa signifierait qu'un autre utilisateur aurait mis √† jour la pizza entre le moment du **`findById`** et du **`save`**.

## Optimistic locking dans une API RESTful avec lecture suivie d'une mise √† jour

### Introduction

Dans une API RESTful, il est courant que le client effectue une requ√™te **`GET`** pour r√©cup√©rer une ressource, puis une requ√™te **`PUT`** ou **`PATCH`** pour la mettre √† jour. Dans ce cas, il est n√©cessaire de v√©rifier que la version de la ressource n'a pas chang√© entre les deux requ√™tes.

Par exemple, si l'on veut assurer que deux clients ne modifient pas en m√™me temps le nom d'un produit, on doit v√©rifier que la version du produit n'a pas chang√© entre la lecture et la mise √† jour. Car si un client lit le produit, puis un autre client modifie le produit, le premier client pourrait √©craser les modifications du second client sans le savoir.

### Principes pour g√©rer l'optimistic locking dans une API RESTful avec lecture suivie d'une mise √† jour

1. Ajouter le champ **`@Version`** dans l'entit√©  
Le champ **`@Version`** est utilis√© pour g√©rer l'optimistic locking. JPA v√©rifie automatiquement ce champ lors de la sauvegarde.


```java {11} showLineNumbers
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private int quantity;

    @Version
    private long version; // Champ utilis√© pour l'optimistic locking

    // Getters et setters
}
```



2. Lecture de la ressource avec la version (GET)  
Lorsqu'un client r√©cup√®re une ressource, incluez la version dans la r√©ponse pour qu'il puisse l'utiliser lors de la mise √† jour.

```java {15} showLineNumbers
@GetMapping("/products/{id}")
public ProductDTO getProduct(@PathVariable Long id) {
    Product product = productRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));

    return new ProductDTO(product.getId(), product.getName(), product.getQuantity(), product.getVersion());
}

// Code pour l'op√©ration de lecture d'un produit
@GetMapping("/products/{id}")
public ProductDTO getProduct(@PathVariable Long id) {
    Product product = productRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));

    return new ProductDTO(product.getId(), product.getName(), product.getQuantity(), product.getVersion());
}
```

3. Mise √† jour de la ressource avec v√©rification de la version (PUT)  
Lors de la mise √† jour, le client doit inclure la version qu'il a re√ßue dans la requ√™te. Si cette version ne correspond pas √† la version actuelle de la ressource, on d√©cide de lever une exception **`OptimisticLockException`** seulement si le nom du produit a √©t√© mis √† jour.  
De plus, JPA effectue automatiquement la v√©rification de la version si le champ **`@Version`** est pr√©sent dans l'entit√© et que vous utilisez une m√©thode comme **`save()`** pour persister l'entit√©. Lorsque vous appelez **`productRepository.save(product)`**, JPA compare la version de l'entit√© en m√©moire avec celle en base de donn√©es.  
Si elles ne correspondent pas (par exemple, si un autre client a modifi√© la ressource entre-temps), une exception **`OptimisticLockException`** est aussi lev√©e.

```java {13-17} showLineNumbers
// Code pour l'op√©ration de mise √† jour d'un produit
@Transactional
@PutMapping("/products/{id}")
public ResponseEntity<Void> updateProduct(@PathVariable Long id, @RequestBody UpdateProductRequest request) {
    Product product = productRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));

    if(product.getQuantity() < request.getQuantityToRemove()) {
        throw new RuntimeException("Stock insuffisant");
    }

    // V√©rification explicite de la version 
    if (!product.getVersion().equals(request.getVersion())) {
      if(!product.getName().equals(request.getName())) {
        throw new OptimisticLockException("Conflit de version d√©tect√© lors du changement de nom");
      }
    }

    // Mise √† jour du nom
    product.setName(request.getName());

    // Mise √† jour de la quantit√©
    product.setQuantity(product.getQuantity() + request.getQuantityToRemove());
    productRepository.save(product);

    return ResponseEntity.noContent().build();
}

// Code pour UpdateProductRequest
public class UpdateProductRequest {
    private string name;
    private int quantityToRemove;
    private long version; // Version re√ßue lors de la lecture

    // Getters et setters
}
```

4. Gestion des conflits  


```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(OptimisticLockException.class)
    public ResponseEntity<String> handleOptimisticLockException(OptimisticLockException ex) {
        return ResponseEntity.status(HttpStatus.CONFLICT).body("Conflit de version d√©tect√©");
    }
}
```

En cas de conflit de version, le gestionnaire global d'exceptions renvoie une r√©ponse **`409 Conflict`** au client.  

Le client peut alors g√©rer ce cas en r√©cup√©rant √† nouveau la ressource, en affichant un message √† l'utilisateur ou en effectuant une autre action appropri√©e.  
Notamment, en cas de tentative de modification du nom du produit, le client peut afficher un message √† l'utilisateur pour l'informer du conflit et lui demander de confirmer la modification.

Il faudrait bien s√ªr adapter ce code √† votre application, en fonction de vos besoins et de votre architecture. Par exemple, vous pourriez ajouter un champs pour g√©rer la confirmation de la modification du nom du produit, ou ajouter des informations suppl√©mentaires dans la r√©ponse pour aider le client √† g√©rer le conflit.

## En savoir plus

Si vous souhaitez en savoir plus sur l'optimistic locking, vous pouvez consulter cet article : https://www.baeldung.com/jpa-optimistic-locking

# <InternalPageTitle> Pessimistic Locking dans Spring Boot </InternalPageTitle>

## Introduction

Le pessimistic locking repose sur l'id√©e que les conflits sont fr√©quents. Avant de mettre √† jour une donn√©e, on verrouille la ressource pour emp√™cher tout autre processus de la modifier.

Le pessimistic locking est id√©al pour les sc√©narios o√π les conflits sont fr√©quents, comme la mise √† jour d'un stock de produits lorsque le stock peut √™tre modifi√© par √©norm√©ment d'utilisateurs en m√™me temps.

## Bases pour le pessimistic locking

Voici un exemple de pessimistic locking en Java avec JPA :

```java {2,15} showLineNumbers
// Partie du service pour mettre √† jour le stock d'un produit
@Transactional
public void updateStockWithPessimisticLock(Long productId, int quantityToAdd) {
    Product product = productRepository.findByIdWithLock(productId)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));

    product.setQuantity(product.getQuantity() + quantityToAdd);
    productRepository.save(product);
}

// Repository

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    Optional<Product> findById(Long productId);
}
```

Avec JPA, vous pouvez utiliser **`@Lock`** directement sur la m√©thode **`findById`** pour appliquer un verrou pessimiste sans avoir besoin d'une requ√™te personnalis√©e.

**`@Lock(LockModeType.PESSIMISTIC_WRITE)`** : Cette annotation permet d'appliquer un verrou pessimiste en √©criture sur la ressource. Cela signifie que la ressource est verrouill√©e pour emp√™cher tout autre processus de la modifier.

Dans cet exemple, le verrou pessimiste est appliqu√© lors de la recherche du produit √† mettre √† jour. Cela garantit qu'aucun autre processus ne peut modifier le produit tant que le verrou n'est pas lib√©r√©. A quel moment le verrou est-il lib√©r√© ? Le verrou est g√©n√©ralement lib√©r√© √† la fin de la transaction, c'est-√†-dire lorsque la m√©thode annot√©e avec **`@Transactional`** se termine.

Que se passe-t-il si un autre processus essaie de lire ou de modifier la ressource verrouill√©e ? Imaginons que 10 utilisateurs essaient de mettre √† jour le stock d'un produit en m√™me temps. Le premier utilisateur obtient le verrou et met √† jour le stock. Les 9 autres utilisateurs attendent que le verrou soit lib√©r√©. Une fois que le premier utilisateur a termin√©, le verrou est lib√©r√© et un des 9 autres utilisateurs obtient le verrou et met √† jour le stock. Les 8 autres utilisateurs attendent, et ainsi de suite.

## Probl√®me √©ventuel de performance 

Le pessimistic locking peut entra√Æner des probl√®mes de performance si les verrous sont maintenus trop longtemps. Par exemple, si un utilisateur obtient un verrou et met √† jour le stock, mais ne termine pas l'op√©ration, le verrou est maintenu et les autres utilisateurs doivent attendre. Cela peut entra√Æner des probl√®mes de latence et de ralentissement.

Heureusement, si une exception est lev√©e, gr√¢ce √† la transaction **`@Transactional`**, le verrou est automatiquement lib√©r√©. 

Pour √©viter que les verrous ne soient maintenus trop longtemps, il est recommand√© de limiter la dur√©e des transactions en ajoutant un timeout. Par exemple, vous pouvez ajouter une annotation **`@Transactional(timeout = 10)`** pour limiter la dur√©e de la transaction √† 10 secondes. Si la transaction ne se termine pas dans les 10 secondes, une exception est lev√©e et le verrou est lib√©r√©.

Comment s'appelle l'exception lev√©e en cas de timeout ? L'exception lev√©e en cas de timeout est une **`TransactionTimedOutException`**. Cette exception est lev√©e si la transaction ne se termine pas dans le d√©lai imparti.

Voici notre exemple de pessimistic locking avec un timeout :

```java {1} showLineNumbers
@Transactional(timeout = 10)
public void updateStockWithPessimisticLock(Long productId, int quantityToAdd) {
    Product product = productRepository.findByIdWithLock(productId)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));

    product.setQuantity(product.getQuantity() + quantityToAdd);
    productRepository.save(product);
}

// Repository

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    Optional<Product> findById(Long productId);
}

```

## Exemple concret

Veuillez mettre √† jour votre projet GitLab contenant la gestion des Pizzas et des Boissons pour ajouter le pessimistic locking.

Nous allons imaginer un sc√©nario un peu tir√© par les cheveux o√π 100 utilisateurs essaient en m√™me temps de modifier une boisson. Nous sommes d'accord que c'est peu probable, mais cela nous permettra de simuler un cas de pessimistic locking.

Commen√ßons par mettre √† jour le repository **`DrinkRepository`** pour ajouter le pessimistic locking :

```java {12-21} showLineNumbers
@Repository
public interface DrinkRepository extends CrudRepository<Drink, Long> {

  /**
   * Find all drinks with a price less than or equal to the given price.
   *
   * @param price the price
   * @return the drinks
   */
  Iterable<Drink> findAllByPriceLessThanEqual(double price);

  /**
   * Find a drink by its id.
   *
   * @param id the id
   * @return the drink
   */
  @Override
  @NonNull
  @Lock(LockModeType.PESSIMISTIC_WRITE)
  Optional<Drink> findById(@NonNull Long id);
}
```

Nous avons ajout√© l'annotation **`@Lock(LockModeType.PESSIMISTIC_WRITE)`** sur la m√©thode **`findById`** pour appliquer un verrou pessimiste en √©criture sur la ressource. Cela signifie que la ressource renvoy√©e par cette m√©thode est verrouill√©e pour emp√™cher tout autre processus de la modifier.

Ensuite, mettons √† jour le service **`DrinkService`** pour l'op√©ration de mise √† jour d'une boisson :

```java {3,15} showLineNumbers
@Transactional(timeout = 10)
  public Drink updateOneDrink(long id, NewDrink newDrink) {
    Drink drink = drinkRepository.findById(id).orElse(null);
    if (drink == null) {
      return null;
    }

    if (newDrink.getTitle() != null) {
      drink.setTitle(newDrink.getTitle());
    }
    if (newDrink.getImage() != null) {
      drink.setImage(newDrink.getImage());
    }
    if (newDrink.getVolume() > 0.0) {
      drink.setVolume(newDrink.getVolume());
    }
    if (newDrink.getPrice() > 0.0) {
      drink.setPrice(newDrink.getPrice());
    }

    return drinkRepository.save(drink);
  }
```

> Attention, pour importer l'annotation **`@Transactional`**, vous devez ajouter l'import de **`springframework`** et pas de **`jakarta`** :

```java
import org.springframework.transaction.annotation.Transactional;
```

Nous avons ajout√© l'annotation **`@Transactional(timeout = 10)`** pour limiter la dur√©e de la transaction √† 10 secondes. Si la transaction ne se termine pas dans les 10 secondes, une exception **`TransactionTimedOutException`** est lev√©e et le verrou est lib√©r√©.

Via le client HTTP d'IntelliJ, nous ne pouvons pas simuler un cas de pessimistic locking, car les requ√™tes sont ex√©cut√©es de mani√®re s√©quentielle.  
Pour ce cours, nous ne simulerons pas de cas de pessimistic locking, mais vous pouvez imaginer que si 100 utilisateurs tentent de modifier la m√™me boisson en m√™me temps, il peut y avoir des probl√®mes de coh√©rence des donn√©es.  
Ici le syst√®me de verrous assure que seul un utilisateur √† la fois peut modifier une boisson. Les autres utilisateurs doivent attendre que le verrou soit lib√©r√©.  
Bien s√ªr, ce type de sc√©nario est peu probable dans la vraie vie, et est acceptable si l'on accepte que les donn√©es de la ressource puissent √™tre modifi√©es √† tour de r√¥le, garantissant la coh√©rence des donn√©es pour chaque modification, mais pas entre les modifications. 

En effet, si un utilisateur modifie une boisson, puis un autre utilisateur modifie la m√™me boisson, la deuxi√®me modification √©crasera la premi√®re, sans que cela ne pose de probl√®me de coh√©rence des donn√©es. 

Mais qui d√©tient la v√©rit√© au niveau des donn√©es ? Le dernier utilisateur ? Si la r√©ponse √† cette question est oui, alors le pessimistic locking est une bonne solution. Si la r√©ponse est non, alors il faudra trouver une autre solution pour g√©rer la concurrence.  

üí≠ Quelle genre de solution ?  
Une solution pourrait √™tre d'utiliser l'optimistic locking, qui permet de g√©rer les conflits de version entre les modifications de la ressource.  Il faudra alors renvoyer des codes HTTP d'erreurs aux utilisateurs qui tentent de modifier une ressource qui a √©t√© modifi√©e entre-temps, et leur demander de recharger la ressource pour obtenir la version la plus r√©cente.

Si n√©cessaire, vous pouvez trouver le code associ√© √† la gestion de transactions et de la concurrence ici : [concurrency](https://github.com/e-vinci/cae-theory-demos/tree/main/concurrency).

## En savoir plus

Si vous souhaitez en savoir plus sur le pessimistic locking, vous pouvez consulter cet article : https://www.baeldung.com/jpa-pessimistic-locking

