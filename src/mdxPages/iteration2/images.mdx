---
title: Images
description: Gestion des images
date: 24/02/2025
---

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> CAE </PathViewerItem>
    <PathViewerItem to="/iteration2"> Itération 2 </PathViewerItem>
    <PathViewerItem selected> Gestion des images </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Comment gérer des assets ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment fonctionne un service de stockage d'objets ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment créer un service de stockage sur Azure ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment utiliser le service de stockage via l'API ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment tester une opération de l'API qui attend une image ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment faire un upload d'images via le frontend ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment utiliser le service de stockage dans l'environnement de staging ? </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Comment gérer des assets ? </InternalPageTitle>

## Introduction

Les assets sont des ressources statiques (images, vidéos, fichiers de styles, etc.) qui sont utilisées dans une application. 

Il existe différents moyens de mettre à disposition ces ressources pour une application web. Voici les moyens les plus courants :
- **Importer les assets dans le code source du frontend** : Les assets sont importés dans le code source de l'application. Cela peut être fait en utilisant des imports dans le code source (ex: `import image from './image.png'`) ou en fournissant un chemin relatif vers l'asset qui se trouve dans le répertoire **`public`** (ex: `<img src="/image.png" />`).
- **Héberger les assets via un serveur de fichiers statiques associé à l'API** : Les assets sont stockés dans un serveur de fichiers statiques mis à disposition par l'API. L'API fournit alors des URLs pour accéder aux assets.
- **Offrir des opérations de l'API dédiées à la gestion des assets** : L'API expose des opérations dédiées à la gestion des assets (ex: create, read, delete). Ces opérations permettent de stocker et de récupérer les assets de manière sécurisée. L'API peut stocker les assets :
  - dans un système de fichiers ;
  - dans une base de données.
- **Utiliser un service tiers de gestion des assets** : Un service tiers spécialisé dans la gestion des assets est utilisé pour stocker et gérer les assets. Un exemple de service tiers est **placid**.
- **Héberger les assets dans un service de stockage d'objets** : Les assets sont stockés dans un service de stockage d'objets (ex: AWS S3, Google Cloud Storage). L'API fournit alors des URLs pour accéder aux assets.

Nous allons explorer ces différentes approches dans les sections suivantes.

## Importer les assets dans le code source du frontend

L'import des assets dans le code source du frontend est une approche simple et courante pour gérer les images dans une application web. 

Cela fonctionne lorsque nous avons un nombre limité d'images et que ces images ne changent pas fréquemment.

Bien entendu, cette approche ne fonctionne que pour des images prédéfinies, utiles lorsque l'on souhaite afficher des images de logo, des icônes, des images de produits par défaut, etc.

Si l'on souhaite permettre aux utilisateurs d'ajouter des images, cette approche n'est pas adaptée.

Cette approche pourra être utilisée dans le projet CAE pour les images de logo, les icônes, etc. Pour les fichiers dynamiques, nous utiliserons une autre approche.

## Héberger les assets via un serveur de fichiers statiques associé à l'API

L'hébergement des assets via un serveur de fichiers statiques associé à l'API est une approche courante pour stocker des assets dans une application web.

Dans cette approche, les assets sont stockées dans un répertoire dédié du serveur de fichiers statiques. L'API expose alors des URLs pour accéder aux assets.

Cette approche est principalement utile pour des assets qui sont statiques. Si l'on souhaite stocker des assets dynamiquement (ex: upload d'images par les utilisateurs), il va falloir créer des opérations dédiées (cas suivant) dans l'API pour gérer ces assets.

Les inconvénients de cette approche sont les suivants :
- Les assets sont stockées sur le même serveur que l'API, ce qui peut entraîner une surcharge du serveur si le nombre d'assets est important.
- Les URLs des assets sont directement accessibles, ce qui peut poser des problèmes de sécurité (ex: accès non autorisé aux images).
- Si l'on doit d'office **Offrir des opérations de l'API dédiées à la gestion des assets** (voir le cas suivant), alors autant jouer la carte de la sécurité et ne pas utiliser d'URLs directes pour les assets.

Nous n'allons donc pas utiliser cette approche dans notre projet CAE. Néanmoins, si vous êtes intéressé par cette approche, vous pourrez tenter de le faire par vous même pour l'environnement de développement.


## Offrir des opérations de l'API dédiées à la gestion des assets

Offrir des opérations de l'API dédiées à la gestion des assets est une approche plus sécurisée pour stocker et gérer les assets dans une application web.

Dans cette approche, l'API expose des opérations dédiées pour stocker, récupérer et supprimer des assets. Les assets peuvent être stockées dans un système de fichiers ou dans une base de données.

Cette approche est particulièrement utile lorsque l'on souhaite stocker des assets dynamiquement (ex: upload d'images par les utilisateurs).

Généralement, on va stocker les assets dans un répertoire dédié du serveur de l'API. L'API va alors gérer les opérations de stockage, de récupération et de suppression des assets. 
L'avantage de cette approche est que l'on peut contrôler l'accès aux assets et garantir leur sécurité.

On utilise moins souvent une base de données pour stocker les assets, pour ces raisons :
- Les bases de données ne sont pas optimisées pour stocker des fichiers binaires (ex: images), les opérations de lecture et d'écriture peuvent être plus lentes.
- Le stockage en DB coûte cher !
- Un asset enregistré dans une base de données prend plus de place qu'un fichier stocké sur le disque (passage en base64 et overhead pour la gestion des enregistrements, des index et des métadonnées). Quel pourcentage ? Cela dépend de la taille des fichiers et de la base de données utilisée, mais on peut estimer cela à environ 30-40%.
- Les bases de données peuvent devenir rapidement surchargées si l'on stocke des fichiers binaires.

Les inconvénients de cette approche, d'offrir des opérations de l'API pour la gestion des assets, sont les suivants :
- La complexité de la gestion des opérations de stockage, de récupération et de suppression des assets. Il faut gérer les autorisations, les contrôles d'accès, les quotas de stockage, etc.
- La surcharge du serveur de l'API si le nombre d'assets est important.

Nous n'allons donc pas utiliser cette approche dans notre projet CAE.

## Utiliser un service tiers de gestion des assets

Utiliser un service tiers de gestion des assets est une approche intéressante pour stocker et gérer les assets dans une application web.

Un service tiers spécialisé dans la gestion des assets offre généralement des fonctionnalités avancées pour stocker, récupérer et supprimer des assets. Ces services sont souvent optimisés pour gérer des fichiers binaires (ex: images, vidéos, fichiers audio...).

Un exemple de service tiers de gestion des assets est **placid**. Placid permet de stocker des images et de les manipuler (redimensionner, recadrer, compresser, etc.) via une API.

Les avantages de cette approche sont les suivants :
- Les services tiers de gestion des assets offrent des fonctionnalités avancées pour manipuler les assets (ex: redimensionner, recadrer, compresser).
- Les services tiers de gestion des assets sont souvent optimisés pour gérer des fichiers binaires.
- Les services tiers de gestion des assets offrent généralement des fonctionnalités de sécurité avancées (ex: contrôle d'accès, chiffrement).

Les inconvénients de cette approche sont les suivants :
- Les services tiers de gestion des assets peuvent être coûteux.
- Les services tiers de gestion des assets peuvent être moins flexibles que des solutions auto-hébergées.
- Il faut souvent utiliser un clé d'API pour accéder aux services tiers de gestion des assets, ce qui peut poser des problèmes de sécurité. Il faut alors bien protéger cette clé d'API et donc créer ses propres opérations de l'API pour gérer les accès à ces services tiers. On retombe alors sur le cas précédent (**Offrir des opérations de l'API dédiées à la gestion des assets** !).

Nous n'allons donc pas utiliser cette approche dans notre projet CAE.

## Héberger les assets dans un service de stockage d'objets

Héberger les assets dans un service de stockage d'objets est une approche courante pour stocker des assets dans une application web.

Les services de stockage d'objets (ex: Azure Stockage, AWS S3, Google Cloud Storage) sont optimisés pour stocker des fichiers binaires (ex: images, vidéos, fichiers audio...). Ils offrent des fonctionnalités avancées pour stocker, récupérer et supprimer des assets. Généralement, leur tarification est basée sur l'utilisation (ex: quantité de données stockées, quantité de données transférées) et sont donc très compétitifs.

De plus, les services de stockage d'objets offrent des fonctionnalités de sécurité avancées (ex: contrôle d'accès, chiffrement).

Voici les gros avantages de cette approche :
- On peut déléguer la gestion des assets à un service tiers spécialisé, ce qui permet de se concentrer sur le développement de l'application.
- Les services de stockage d'objets sont optimisés pour stocker des fichiers binaires et offrent des fonctionnalités avancées pour manipuler les assets.
- Les services de stockage d'objets offrent des fonctionnalités de sécurité avancées (ex: contrôle d'accès, chiffrement) qui ne demande pas de gros efforts au niveau de ses propres opérations de l'API. Il y a toujours des efforts à faire lors de l'upload de fichiers, mais ils sont moindres. Nous allons les voir dans la section suivante.
- Pour la lecture de fichiers, il est possible que le frontend accède directement aux URLs des assets, sans passer par l'API, tout en assurant la sécurité des fichiers. Cela peut être un avantage en termes de performance.
- Les services de stockage d'objets sont généralement très compétitifs en termes de tarification.

Nous allons donc utiliser cette approche dans notre projet CAE.

# <InternalPageTitle> Comment fonctionne un service de stockage d'objets ? </InternalPageTitle>

## Introduction

Un service de stockage d'objets est un service cloud qui permet de stocker des fichiers binaires (ex: images, vidéos, fichiers audio...) de manière sécurisée et scalable.

Les services de stockage d'objets sont optimisés pour stocker de gros volumes de données non structurées. Ils offrent des fonctionnalités avancées pour stocker, récupérer et supprimer des objets.

Les services de stockage d'objets sont généralement basés sur une architecture de stockage distribuée. Les données sont répliquées sur plusieurs serveurs pour garantir la disponibilité et la durabilité des données.

## Comment assurer la sécurité des fichiers stockés ?

Pour assurer la sécurité des fichiers stockés dans un service de stockage d'objets, voici quelques bonnes pratiques à suivre :
- **Chiffrement des données au repos** ("Encryption at Rest"): Les données stockées dans le service de stockage d'objets doivent être chiffrées pour garantir leur confidentialité. Les services de stockage d'objets offrent généralement des fonctionnalités de chiffrement des données au repos. Par exemple, Azure Storage chiffre automatiquement les données au repos (chiffrement appliqué à tous les objets stockés dans Azure Blob Storage, Azure Files, Azure Queue Storage et Azure Table Storage) à l'aide de clés de chiffrement gérées par le service.
- **Contrôle d'accès basé sur les rôles** : Les accès aux fichiers stockés dans le service de stockage d'objets doivent être contrôlés en fonction des rôles des utilisateurs. Dans Azure Storage, on peut utiliser les **SAS (Shared Access Signatures)** pour définir des autorisations granulaires sur les objets stockés.
- **Journalisation des accès** : Les accès aux fichiers stockés dans le service de stockage d'objets doivent être journalisés pour permettre la traçabilité des accès. Les services de stockage d'objets offrent généralement des fonctionnalités de journalisation des accès.
- **Gestion des clés d'API** : Les clés d'API utilisées pour accéder au service de stockage d'objets doivent être gérées de manière sécurisée. Azure Storage permet de gérer les clés d'API à l'aide de l'Azure Key Vault.

## Comment gérer les opérations CRUD sur les fichiers ?

Pour gérer les opérations CRUD (Create, Read, Update, Delete) sur les fichiers stockés dans un service de stockage d'objets, voici quelques bonnes pratiques à suivre :
- **Utilisation d'une API RESTful** : Les opérations CRUD sur les fichiers stockés dans le service de stockage d'objets doivent être exposées via une API RESTful. Les services de stockage d'objets offrent généralement des SDK pour faciliter l'intégration avec l'API. Par exemple, Azure Storage propose des SDK pour différentes langages de programmation (C#, Java, Python, Node.js, etc.).
Il existe un **`BlobClientBuilder`** pour manipuler les blobs dans Azure Storage.
- **Gestion des métadonnées** : Les fichiers stockés dans le service de stockage d'objets peuvent être associés à des métadonnées pour faciliter leur gestion. Les métadonnées peuvent être utilisées pour stocker des informations supplémentaires sur les fichiers (ex: type de contenu, taille, date de création, etc.).
- **Gestion des autorisations** : Les accès aux fichiers stockés dans le service de stockage d'objets doivent être contrôlés en fonction des autorisations des utilisateurs. Dans Azure Storage, on peut utiliser les **SAS (Shared Access Signatures)** pour définir des autorisations granulaires sur les objets stockés. Une SAS est un jeton qui peut être ajouté à une URL pour accorder un accès temporaire et limité à une ressource dans Azure Storage. La SAS spécifie les permissions (lecture, écriture, suppression, etc.), la durée de validité et d'autres restrictions d'accès.
- **Gestion des versions** : Les fichiers stockés dans le service de stockage d'objets peuvent être versionnés pour permettre la gestion des versions des fichiers. Les services de stockage d'objets offrent généralement des fonctionnalités de gestion des versions.
Azure Storage propose la gestion des versions pour les blobs.

## Est-il possible de ne pas sécuriser l'accès aux fichiers ?

Il est possible de ne pas sécuriser l'accès aux fichiers stockés dans un service de stockage d'objets, mais cela pose des risques en termes de sécurité. Les fichiers stockés dans le service de stockage d'objets peuvent contenir des informations sensibles (ex: données personnelles, propriété intellectuelle, etc.) qui doivent être protégées.

Si ça n'est pas le cas, alors il est possible de ne pas sécuriser l'accès aux fichiers stockés dans le service de stockage d'objets. Cela peut être utile pour des fichiers publics (ex: images, vidéos, fichiers audio accessibles au public).

Attention que même si l'on n'utilise pas des autorisations pour la lecture des fichiers, il est possible de trouver un compromis au niveau sécurité de cette façon :
- **Création de noms de fichiers complexes** : Les noms de fichiers stockés dans le service de stockage d'objets peuvent être rendus complexes pour limiter l'accès non autorisé. Par exemple, on peut utiliser des UUID (Universal Unique Identifier) comme noms de fichiers.
- **Rendre l'accès public en lecture seule et individuelle aux fichiers** (et pas au niveau du conteneur) : Ainsi il n'est pas possible de lister les fichiers, mais on peut accéder à un fichier seulement si on connaît son URL.

Avec ce compromis, on peut limiter l'accès non autorisé aux fichiers stockés dans le service de stockage d'objets tout en permettant un accès public aux fichiers.

Nous allons utiliser ce compromis pour le projet CAE.

Attention que pour la création et l'effacement de fichier, il est toujours nécessaire de sécuriser l'accès ! Sinon, n'importe qui pourrait créer ou effacer des fichiers dans le service de stockage d'objets 😱 ! 

Ainsi, nous utiliserons un SAS token pour les opération de création et d'effacement de fichiers.

## Comment autoriser l'accès aux fichiers stockés dans le service de stockage avec Azure Stockage ?

Pour autoriser l'accès aux fichiers stockés dans le service de stockage avec Azure Stockage, on peut utiliser les **SAS (Shared Access Signatures)**.

Une SAS est un jeton qui peut être ajouté à une URL pour accorder un accès temporaire et limité à une ressource dans Azure Storage. La SAS spécifie les permissions (lecture, écriture, suppression, etc.), la durée de validité et d'autres restrictions d'accès. 

Voici le workflow que nous utiliserons pour autoriser l'accès aux fichiers stockés dans le service de stockage avec Azure Stockage :

<PlantUML src="/diagrams/azure-storage.puml" alt="Gestion d'images pour le projet avec Azure Stockage" />

Dans un premier temps, les développeurs vont devoir générer une token (SAS) pour les fichiers stockés dans le service de stockage. Cette SAS va spécifier les permissions (lecture, écriture, suppression, etc.), la durée de validité et d'autres restrictions d'accès.

Puis, lorsque l'application est exécutée, le frontend permettra via un formulaire de créer des ressources incluant une image. Lors de la création de la ressource, le frontend va envoyer une requête à l'API avec l'image à stocker. 
En utilisant le token (SAS), l'API va pouvoir stocker l'image dans le service de stockage d'objets.

Finalement, lorsque les utilisateurs consulteront une page affichant les ressources, le frontend va envoyer une requête à l'API pour récupérer les ressources à afficher. L'API va alors récupérer les ressources stockées dans la DB, incluant l'URL vers l'image stockée dans le service de stockage d'objets. Le frontend va alors afficher les ressources, incluant les images stockées dans le service de stockage d'objets. 
NB : si l'on avait souhaité sécuriser au maximum les images, on aurait pu passer par l'API pour qu'elle sauvegarde une SAS URL pour chaque image stockée dans le service de stockage d'objets. Cela aurait permis de contrôler l'accès lors de la lecture des images. Mais pour notre projet, nous avons choisi d'avoir un compromis au niveau sécurité.

# <InternalPageTitle> Comment créer un service de stockage sur Azure ? </InternalPageTitle>

## Introduction

Comme vous le savez déjà, Azure Storage est un service cloud de stockage d'objets qui permet de stocker des fichiers binaires (ex: images, vidéos, fichiers audio...). 

Nous allons à présent voir comment appliquer le workflow que nous avons vu précédemment pour sauvegarder des images dans Azure Storage au sein d'une application existante permettant de créer et afficher des pizzas.

Le point de départ pour ce tutoriel est le site de gestion de la pizzeria comme vu au dernier tutoriel nommé [staging](https://github.com/e-vinci/cae-theory-demos/tree/main/staging). Veuillez donc en faire une copie au sein d'un projet GitLab.

## Création d'un compte de stockage Azure (Storage account)

Pour créer un compte de stockage Azure, vous devez disposer d'un abonnement Azure depuis moins de 12 mois. Si vous êtes étudiant, vous pouvez bénéficier d'un abonnement gratuit Azure for Students.

Veuillez suivre les étapes suivantes pour créer un compte de stockage Azure :
- Connectez-vous à votre [portail Azure](https://portal.azure.com/).
- Dans la recherche, tapez **`Free services`**, puis cliquez sur **`Free services`**.
- Sélectionnez ensuite **`Azure Blob Storage`** (`5 GB locally redundant storage (LRS) hot block with 20,000 read and 10,000 write operations`), puis cliquez sur **`Create`**.
- Sélectionnez votre **`Subscription`** et **`Resource group`**. Pour les étudiants Vinci, cela devrait être **`Azure for Students`**. Si vous n'avez pas de **`Resource group`**, vous pouvez en créer un en cliquant sur **`Create new`** (**`imageGroup`** par exemple).
- Entrez un **`Storage account name`** unique. Par exemple : **`imagestorage007`**.
- Sélectionnez la **`Region`** qui est acceptable dans un plan gratuit. Par exemple : **`West Europe`**.
- Cliquez sur **`Review + create`**, puis sur **`Create`**.
- Attendez que le déploiement soit terminé. Cela peut prendre quelques minutes. Puis cliquez sur **`Go to resource`**.

## Création de deux blobs containers

### Introduction 

Un blob container est un conteneur de stockage d'objets dans Azure Storage. Il est utilisé pour stocker des objets binaires (ex: images, vidéos, fichiers audio...).

Nous souhaitions créer deux blob containers pour stocker les images des pizzas :
- un container pour l'environnement de développement (**`dev`**)
- un container pour l'environnement de staging (**`staging`**)

### Configuration du storage account

Dans un premier temps, il faut s'assurer qu'on aie le droit d'accéder de manière anonyme aux blobs. Cela permettra aux utilisateurs de l'application d'accéder aux images sans avoir besoin de s'authentifier. 

Voici comment faire :
- Dans le portail Azure, cliquez sur **`Storage accounts`** dans le menu de gauche.
- Cliquez sur le **`Storage account`** que vous avez créé précédemment (**`imagestorage007`** par exemple).
- Cliquez dans **`Settings`** sur **`Configuration`**.
- **`Allow Blob anonymous access`** doit être à **`Enabled`**.

### Création du blob container pour l'environnement de développement

Pour créer un blob container pour l'environnement de développement, veuillez suivre les étapes suivantes :
- Dans le portail Azure, cliquez sur **`Storage accounts`** dans le menu de gauche.
- Cliquez sur le **`Storage account`** que vous avez créé précédemment (**`imagestorage007`** par exemple).
- Dans le menu de gauche, sous **`Data storage`**, cliquez sur **`Containers`**.
- Cliquez sur **`+ Container`**.
- Entrez un nom pour le container. Par exemple : **`dev`**.
- Pour **`Anonymous access level`**, sélectionnez **`Blob (anonymous read access for blobs only)`**. Grâce à cela, les blobs peuvent être lus par n'importe qui, mais sans avoir le droit de lister les blobs.
- Laissez les autres paramètres par défaut.
- Cliquez sur **`Create`**.

### Création du blob container pour l'environnement de staging

Pour créer un blob container pour l'environnement de staging, veuillez suivre les étapes suivantes :
- Dans le portail Azure, cliquez sur **`Storage accounts`** dans le menu de gauche.
- Cliquez sur le **`Storage account`** que vous avez créé précédemment (**`imagestorage007`** par exemple).
- Dans le menu de gauche, sous **`Data storage`**, cliquez sur **`Containers`**.
- Cliquez sur **`+ Container`**.
- Entrez un nom pour le container. Par exemple : **`staging`**.
- Laissez les autres paramètres par défaut.
- Cliquez sur **`Create`**.

### Sécurisation des accès via un SAS token

Pour sécuriser les accès aux blobs, nous allons utiliser un SAS token.
Nous allons générer un SAS token pour tous les blobs de notre storage account. Ce SAS token doit permettre la création et la suppression de blobs.

Voici comment faire :
- Dans le portail Azure, cliquez sur **`Storage accounts`** dans le menu de gauche.
- Cliquez sur le **`Storage account`** que vous avez créé précédemment (**`imagestorage007`** par exemple).
- Dans le menu de gauche, sous **`Security + networking`**, cliquez sur **`Shared access signature`**.
- Dans **`Allowed resources types`**, sélectionnez **`Object`**. Un **`Object`** fait référence à une unité de données stockée dans Azure Storage, comme un blob.
- Dans **`Allowed permissions`**, même si c'est juste  **`Create`** et **`Delete`** que nous avons besoin, nous allons laisser toutes les permissions sélectionnées.
- Pour le **`Start time`**, laissez la date actuelle.
- Pour le **`End time`**, sélectionnez une date loin dans le futur. Par exemple, 10 ans plus tard.
- Cliquez sur **`Generate SAS and connection string`**.
- Veuillez conserver :
  - le **`SAS token`** généré, comme par exemple **`sv=2024-11-02&ss=bfqt&srt=o&sp=rwdlacaerpiytfx&se=2035-02-24T23:52:15Z&st=2025-02-24T15:52:15Z&spr=https&sig=OoOvYhdQZFxO79sqdfqsHXHgDw1cCvq%2FeSciIift10CTT54%3D`**.
  - le **`Blob endpoint`** généré, comme par exemple : **`https://imagestorage007.blob.core.windows.net/`**.


# <InternalPageTitle> Comment utiliser le service de stockage via l'API ? </InternalPageTitle>

## Introduction

Maintenant que nous avons créé un service de stockage d'objets sur Azure, nous allons voir comment l'utiliser via l'API pour stocker et récupérer des images.

Dans notre tutoriel, nous allons modifier le service de gestion des pizzas pour qu'il utilise le service de stockage d'objets pour stocker les images des pizzas :
- lors de la création d'une pizza : l'image de la pizza sera stockée dans le service de stockage d'objets ;
- lors de la récupération des pizzas : l'URL de l'image de la pizza sera récupérée depuis la DB.
- lors de la suppression d'une pizza : l'image de la pizza sera supprimée du service de stockage d'objets.

## Configuration de l'API pour utiliser le service de stockage

### Introduction

L'API a besoin de connaître les informations suivantes pour utiliser le service de stockage d'objets :
- le **`Blob endpoint`** : l'URL de base du service de stockage d'objets (ex: **`https://imagestorage007.blob.core.windows.net/`**).
- le **`SAS token`** : le token d'accès partagé pour accéder au service de stockage d'objets (ex: **`sv=2024-11-02&ss=bfqt&srt=o&sp=rwdlacaerpiytfx&se=2035-02-24T23:52:15Z&st=2025-02-24T15:52:15Z&spr=https&sig=OoOvYhdQZFxO79sqdfqsHXHgDw1cCvq%2FeSciIift10CTT54%3D`**).
- le **`Container name`** : le nom du blob container dans lequel les images seront stockées (ex: **`dev`**).

### Configuration de l'API pour l'environnement de développement

Pour configurer l'API pour l'environnement de développement, actuellement, nous utilisons **`application.properties`** pour stocker les configurations. Nous allons ajouter les configurations suivantes :
```properties
azure.blob.service-endpoint=https://imagestorage007.blob.core.windows.net/
azure.blob.container-name=dev
azure.blob.sas-token=${AZURE_BLOB_SAS_TOKEN}

spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
```

Voici quelques explications sur ces configurations :
- **`azure.blob.service-endpoint`** : l'URL de base du service de stockage d'objets (ex: **`https://imagestorage007.blob.core.windows.net/`**). 
- **`azure.blob.container-name`** : le nom du blob container dans lequel les images seront stockées (ex: **`dev`**).
- **`azure.blob.sas-token`** : le token d'accès partagé pour accéder au service de stockage d'objets (ex: **`${AZURE_BLOB_SAS_TOKEN}`**). Nous allons stocker ce token dans une variable d'environnement car c'est un secret qui ne doit pas se trouver dans le code source.
- **`spring.servlet.multipart.enabled`** : active le support de l'upload de fichiers. **`multipart`** signifie que le contenu de la requête est un formulaire multipart, c'est à dire qu'il contient des données de plusieurs types (texte / json, fichier, etc.).
- **`spring.servlet.multipart.max-file-size`** : la taille maximale autorisée pour un fichier.
- **`spring.servlet.multipart.max-request-size`** : la taille maximale autorisée pour une requête.  

Au sein du fichier **`/api/.env`**, nous allons ajouter la propriété **`AZURE_BLOB_SAS_TOKEN`** avec la valeur du SAS token que vous avez noté précédemment. Voici un exemple :
```properties
AZURE_BLOB_SAS_TOKEN=sv=2024-11-02&ss=bfqt&srt=o&sp=rwdlacaerpiytfx&se=2035-02-24T23:52:15Z&st=2025-02-24T15:52:15Z&spr=https&sig=OoOvYhdQZFxO79sqhhqsHXHgDw1cbvq%2FeSciIift10XRT74%3D
```

Pour rappel, lorsque nous utiliserons IntelliJ pour lancer l'API, comme nous avons installé la dépendance **`spring-dotenv`**, les variables d'environnement stockées dans le fichier **`/api/.env`** seront automatiquement chargées.

## Configuration de nginx pour servir les images

### Introduction

Par défaut, nginx ne permet pas de servir des requêtes qui sont plus grande que 1MB. Nous allons donc modifier la configuration de nginx pour augmenter cette limite à 10MB.

### Modification de la configuration de nginx

Pour modifier la configuration de nginx, nous allons ajouter une directive **`client_max_body_size`** dans le fichier de configuration de nginx.

Veuillez mettre à jour le fichier de configuration de nginx dans **`/reverse-proxy/nginx.conf`** comme suit :

```nginx {9} showLineNumbers
events {
}

http {
    include /etc/nginx/mime.types;
    
    server {
        listen 80;
        client_max_body_size 10M;

        # Proxy API requests
        location /api/ {
            proxy_pass http://api:3000/; # Forward to the API service
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Redirect all other requests to SPA
        location / {
            proxy_pass http://frontend:5172; # Forward to the SPA service
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

    }
}
```

## Création d'une opération pour stocker une image dans le service de stockage

### Introduction

Nous allons maintenant mettre à jour l'API pour ajouter une opération permettant de stocker une image dans le service de stockage d'objets lors de la création d'une pizza.

Actuellement, voici à quoi ressemble l'opération de création d'une pizza (dans le fichier **`controllers/PizzaController.java`**) :
```java
  @PostMapping({"", "/"})
  @PreAuthorize("hasRole('ROLE_ADMIN')")
  public Pizza addPizza(@RequestBody NewPizza newPizza) {
    if (newPizza == null
        || newPizza.getTitle() == null
        || newPizza.getTitle().isBlank()
        || newPizza.getContent() == null
        || newPizza.getContent().isBlank()) {
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST);
    }

    return pizzaService.createPizza(newPizza);
  }
```

Ici l'opération de création d'une pizza prend en paramètre un objet **`NewPizza`** qui contient le titre et le contenu de la pizza. Nous allons maintenant ajouter un champ **`image`** à l'objet **`NewPizza`** pour stocker l'image de la pizza.

### Modification du controller

Voici les modifications à faire :

```java {3-4,13}
  @PostMapping({"", "/"})
  @PreAuthorize("hasRole('ROLE_ADMIN')")
  public Pizza addPizza(@RequestPart("newPizza") NewPizza newPizza,
      @RequestPart("image") MultipartFile image) {
    if (newPizza == null
        || newPizza.getTitle() == null
        || newPizza.getTitle().isBlank()
        || newPizza.getContent() == null
        || newPizza.getContent().isBlank()) {
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST);
    }

    return pizzaService.createPizza(newPizza, image);
  }
```

Voici les explications sur ces modifications :
- **`@RequestPart("newPizza")`** : permet de récupérer l'objet **`NewPizza`** envoyé dans le corps de la requête. Le type MIME de la requête doit être **`multipart/form-data`**. Ce type de requête est utilisé pour envoyer des données de plusieurs types (texte / json, fichier, etc.).
- **`@RequestPart("image")`** : permet de récupérer le fichier nommé **`image`** envoyé dans le corps de la requête.
- **`MultipartFile`** : est une classe fournie par Spring pour représenter un fichier envoyé dans une requête multipart. Elle contient des méthodes pour accéder aux données du fichier (ex: nom, type MIME, contenu).
- **`pizzaService.createPizza(newPizza, image)`** : appelle la méthode **`createPizza`** du service de gestion des pizzas en passant l'objet **`NewPizza`** et le fichier image en paramètres. Nous allons prochainement modifier cette méthode.

### Installation de la dépendance Azure Blob Storage

Pour utiliser le service de stockage d'objets Azure Blob Storage, nous allons ajouter la dépendance **`azure-storage-blob`** à notre projet. Dans **`/api/pom.xml`**, ajoutez la dépendance suivante :

```xml
    <dependency>
      <groupId>com.azure</groupId>
      <artifactId>azure-storage-blob</artifactId>
      <version> 12.27.0</version>
    </dependency>
```

### Modification de l'entité Pizza

Nous allons ajouter un champ **`imageLocation`** à l'entité **`Pizza`** pour stocker l'URL de l'image de la pizza. Voici les modifications à faire dans l'entité **`Pizza`** (dans le fichier **`models/entities/Pizza.java`**) :

```java {13-14}
  public class Pizza {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(nullable = false)
  private String title;

  @Column(nullable = false)
  private String content;

  @Column(nullable = true)
  private String imageLocation;
}
```

### Modification du service de gestion des pizzas

Voici les modifications à faire dans le service de gestion des pizzas (dans le fichier **`services/PizzaService.java`**) pour mettre à jour la méthode **`createPizza`** (n'oubliez pas d'importer les classes nécessaires) :

```java {5-7,11-13,15-17,27-30,35-66} showLineNumbers
@Service
public class PizzaService {

  private final PizzaRepository pizzaRepository;
  private final String blobServiceEndpoint;
  private final String sasToken;
  private final String containerName;

  //...
  public PizzaService(PizzaRepository pizzaRepository,
      @Value("${azure.blob.service-endpoint}") String blobServiceEndpoint,
      @Value("${azure.blob.sas-token}") String sasToken,
      @Value("${azure.blob.container-name}") String containerName) {
    this.pizzaRepository = pizzaRepository;
    this.blobServiceEndpoint = blobServiceEndpoint;
    this.sasToken = sasToken;
    this.containerName = containerName;
  }

  //...

  public Pizza createPizza(NewPizza newPizza, MultipartFile image) {
      Pizza pizza = new Pizza();
      pizza.setTitle(newPizza.getTitle());
      pizza.setContent(newPizza.getContent());

      if (image != null && !image.isEmpty()) {
        String blobUrl = uploadImageToBlob(image);
        pizza.setImageLocation(blobUrl);
      }

      return pizzaRepository.save(pizza);
    }

    /**
     * Upload an image to a blob on Azure storage with a generated UUID as filename.
     * The image is uploaded to the "images" folder.
     * The original filename is stored in the metadata.
     * @param image
     * @return the blob url
     * @throws IOException
     */
    private String uploadImageToBlob(MultipartFile image) {
    String imageUUID = UUID.randomUUID().toString();
    Map<String, String> metadata = new HashMap<>();

    String blobName = imageUUID;

    metadata.put("originalFileName", image.getOriginalFilename());
    BlobClientBuilder blobClientBuilder = new BlobClientBuilder()
        .endpoint(blobServiceEndpoint)
        .sasToken(sasToken)
        .containerName(containerName)
        .blobName(blobName);

    try {
      blobClientBuilder.buildClient().upload(image.getInputStream(), image.getSize(), true);
      blobClientBuilder.buildClient().setMetadata(metadata);
    } catch (IOException e) {
      throw new RuntimeException(e);
    }
    blobClientBuilder.buildClient()
        .setHttpHeaders(new BlobHttpHeaders().setContentType(image.getContentType()));

    return blobClientBuilder.buildClient().getBlobUrl();
  }
  //....
```

Voici les explications sur ces modifications :
- **`@Value("${azure.blob.service-endpoint}") String blobServiceEndpoint`** : injecte la valeur de la propriété **`azure.blob.service-endpoint`** dans le champ **`blobServiceEndpoint`**. Cette propriété provient du fichier **`application.properties`**, le fichier de configuration de l'API en mode développement.
- **`@Value("${azure.blob.sas-token}") String sasToken`** : injecte la valeur de la propriété **`azure.blob.sas-token`** dans le champ **`sasToken`**. Cette propriété provient du fichier **`application.properties`**, le fichier de configuration de l'API en mode développement.
- **`@Value("${azure.blob.container-name}") String containerName`** : injecte la valeur de la propriété **`azure.blob.container-name`** dans le champ **`containerName`**. Cette propriété provient aussi du fichier **`application.properties`**.
- **`uploadImageToBlob`** : est une méthode privée qui permet de stocker une image dans le service de stockage d'objets. Elle prend en paramètre un objet **`MultipartFile`** qui représente le fichier image à stocker. Elle retourne l'URL du blob dans lequel l'image a été stockée. Cette méthode utilise la bibliothèque **`azure-storage-blob`** pour interagir avec le service de stockage d'objets Azure Blob Storage :
  - **`UUID.randomUUID().toString()`** : génère un UUID (Universal Unique Identifier) pour le nom du blob. Cela permet de garantir que le nom du blob est unique. De plus, cela permet de cacher le nom du fichier original, permettant de sécuriser l'accès aux fichiers stockés. Seulement un utilisateur ayant l'URL du blob pourra accéder à l'image. Il est difficile pour des utilisateurs malveillants de deviner l'URL du blob.
  - **`Map<String, String> metadata = new HashMap<>()`** : crée une map pour stocker les métadonnées du blob. Ici, nous stockons le nom du fichier original dans les métadonnées. Cela permet de conserver le nom du fichier original pour une utilisation ultérieure.
  - **`BlobClientBuilder blobClientBuilder = new BlobClientBuilder()`** : crée un **`BlobClientBuilder`** pour interagir avec le service de stockage d'objets Azure Blob Storage. Le **`BlobClientBuilder`** permet de créer, lire, mettre à jour et supprimer des blobs.
  - **`blobClientBuilder.buildClient().upload(image.getInputStream(), image.getSize(), true)`** : stocke le fichier image dans le blob. Nous utilisons la méthode **`upload`** pour stocker le contenu du fichier image dans le blob. Nous passons le flux d'entrée du fichier image, la taille du fichier image et **`true`** pour indiquer que le fichier doit être écrasé s'il existe déjà.
  - **`blobClientBuilder.buildClient().setMetadata(metadata)`** : définit les métadonnées du blob. Ici, nous stockons le nom du fichier original dans les métadonnées.
  - **`blobClientBuilder.buildClient().setHttpHeaders(new BlobHttpHeaders().setContentType(image.getContentType()))`** : définit les en-têtes HTTP du blob. Ici, nous définissons le type MIME du blob en fonction du type MIME du fichier image.
  - **`blobClientBuilder.buildClient().getBlobUrl()`** : retourne l'URL du blob. Cette URL peut être utilisée pour accéder au contenu du blob. C'est cette URL que nous stockons dans le champ **`imageLocation`** de l'entité **`Pizza`**, afin de la sauvegarder dans la DB.

  Pour ce tutorial, nous allons aussi nous occuper de mettre à jour la méthode permettant d'effacer une pizza. Nous ne traiterons pas de l'update d'une pizza pour ce tutorial.

### Effacer une image dans le service de stockage

Nous allons maintenant mettre à jour l'API pour ajouter une opération permettant d'effacer l'image d'une pizza dans le service de stockage d'objets lors de la suppression d'une pizza.

Veuillez modifier le service de gestion des pizzas (dans le fichier **`services/PizzaService.java`**) :

```java {4-6,12-29} showLineNumbers
public Pizza deletePizza(Long id) {
    Pizza pizza = pizzaRepository.findById(id).orElse(null);
    if (pizza != null) {
      if (pizza.getImageLocation() != null) {
        deleteImageFromBlob(pizza.getImageLocation());
      }
      pizzaRepository.delete(pizza);
    }
    return pizza;
  }

  /**
   * Delete an image from the blob storage.
   *
   * @param imageLocation the image location
   */
  private void deleteImageFromBlob(String imageLocation) {
    if (imageLocation != null && !imageLocation.isEmpty() && imageLocation.contains(
        blobServiceEndpoint)) {
      String blobName = imageLocation.substring(imageLocation.lastIndexOf("/") + 1);
      BlobClientBuilder blobClientBuilder = new BlobClientBuilder()
          .endpoint(blobServiceEndpoint)
          .sasToken(sasToken)
          .containerName(containerName)
          .blobName(blobName);

      blobClientBuilder.buildClient().delete();
    }
  }
```

La nouvelle méthode **`deleteImageFromBlob`** permet de supprimer une image du service de stockage d'objets. Elle prend en paramètre l'URL de l'image à supprimer. Voici les explications sur cette méthode :
- **`blobName`** : extrait le nom du blob à partir de l'URL de l'image. L'URL de l'image est de la forme **`https://imagestorage007.blob.core.windows.net/dev/imageUUID`**. Nous extrayons le nom du blob **`imageUUID`** à partir de l'URL.
- **`BlobClientBuilder blobClientBuilder = new BlobClientBuilder()`** : crée un **`BlobClientBuilder`** pour interagir avec le service de stockage d'objets Azure Blob Storage.
- **`blobClientBuilder.buildClient().delete()`** : supprime le blob. 

# <InternalPageTitle> Comment tester une opération de l'API qui attend une image ? </InternalPageTitle>

## Introduction

Maintenant que nous avons mis à jour l'API pour stocker et récupérer des images dans le service de stockage d'objets, nous allons voir comment tester une opération de l'API qui attend une image.

Nous allons utiliser IntelliJ HTTP Client pour tester l'opération de création d'une pizza qui attend une image.

## Création d'une pizza avec une image

Veuillez ajouter cette image dans **`/api/src/test`** : 
<LinkFile name="/files/pizza.png" download>pizza.png</LinkFile>

Pour tester l'opération de création d'une pizza avec une image, veuillez ajouter cette requête dans votre fichier **`/api/src/test/pizzas.http`**  :

```http
#### Create a pizza with the admin token and an image
#### Create a pizza with the admin token
POST {{baseUrl}}/pizzas
Content-Type: multipart/form-data; boundary=boundary
Authorization: {{adminToken}}

--boundary
Content-Disposition: form-data; name="newPizza"
Content-Type: application/json

{
  "title":"Magic Green",
  "content":"Epinards, Brocolis, Olives vertes, Basilic"
}
--boundary
Content-Disposition: form-data; name="image"; filename="pizza.png"
Content-Type: image/png

// The 'pizza.png' file will be uploaded
< ./pizza.png

--boundary
```

Quelques explications sur cette requête :
- **`boundary`** : est une chaîne de caractères qui délimite les parties du formulaire multipart. Chaque partie du formulaire multipart commence par **`--boundary`** et se termine par **`--boundary`**. 
- **`Content-Disposition: form-data; name="newPizza"`** : indique que la partie du formulaire multipart contient l'objet **`NewPizza`**. Le type MIME de la partie est **`application/json`**.
- **`Content-Disposition: form-data; name="image"; filename="pizza.png"`** : indique que la partie du formulaire multipart contient le fichier image. Le nom du fichier est **`pizza.png`**. Le type MIME de la partie est **`image/png`**.
- **`< ./pizza.png`** : indique que le contenu du fichier **`pizza.png`** doit être envoyé dans la partie du formulaire multipart.

Veuillez vous assurer que votre API est bien lancée dans IntelliJ. Puis, exécutez la requête en cliquant sur **`Send Request`** (N'oubliez pas d'exécuter la requête de login de l'admin auparavant, et du register de l'admin encore auparavant si nécessaire via **`auths.http`**). Vous devriez recevoir une réponse avec le statut **`200 OK`** et le corps de la réponse devrait contenir les informations de la pizza créée.

## Récupération de l'URL de l'image de la pizza

Pour récupére l'URL d'une pizza, il suffit de récupérer une pizza via l'API. 

N'hésitez pas à faire la requête permettant de lire toutes les pizzas pour récupérer l'URL de l'image de la pizza que vous venez de créer.

## Effacement d'une pizza avec une image

Pour tester l'opération de suppression d'une pizza avec une image, il vous suffit de faire une requête de suppression d'une pizza via l'API.

N'hésitez pas à faire la requête permettant de supprimer la pizza que vous venez de créer.
Et n'oubliez pas de vérifier que l'image a bien été effacée du service de stockage d'objets.

## Conclusion sur la gestion des images avec Azure Stockage

Dans ce tutoriel, nous avons vu comment utiliser le service de stockage d'objets Azure Blob Storage pour stocker et récupérer des images dans une application Spring Boot. Nous avons vu comment configurer le service de stockage d'objets Azure Blob Storage, comment stocker des images dans le service de stockage d'objets Azure Blob Storage lors de la création d'une pizza, comment récupérer des images stockées dans le service de stockage d'objets Azure Blob Storage lors de la récupération des pizzas, et comment effacer des images stockées dans le service de stockage d'objets Azure Blob Storage lors de la suppression d'une pizza.

Nous avons également vu comment tester une opération de l'API qui attend une image en utilisant IntelliJ HTTP Client.

Nous allons maintenant voir comment mettre à jour le frontend pour faire un formulaire permettant de créer une pizza avec une image, et comment afficher les images des pizzas dans l'application frontend.

# <InternalPageTitle> Comment faire un upload d'images via le frontend </InternalPageTitle>

## Introduction

Nous souhaitons mettre à jour le frontend pour permettre aux utilisateurs de créer des pizzas avec des images. Pour cela, nous allons ajouter un formulaire qui permettra de sélectionner une image lors de la création d'une pizza.

## Mise à jour du formulaire de création de pizza

Veuillez mettre à jour le formulaire de création de pizza pour permettre de sélectionner une image. Pour ce faire, veuillez modifier **`/frontend/src/components/pages/AddPizzaPage.tsx`** :

```tsx {5,14,18,34-38,83-95} showLineNumbers
import { useState, SyntheticEvent } from 'react';
import { useNavigate, useOutletContext } from 'react-router-dom';

import { PizzeriaContext } from '../../types';
import { Box, Button, TextField, useTheme } from '@mui/material';

const AddPizza = () => {
  const theme = useTheme();
  const { addPizza }: PizzeriaContext = useOutletContext();

  const navigate = useNavigate();
  const [pizza, setPizza] = useState('');
  const [description, setDescription] = useState('');
  const [image, setImage] = useState<File | undefined>(undefined);

  const handleSubmit = (e: SyntheticEvent) => {
    e.preventDefault();
    addPizza({ title: pizza, content: description, image });
    navigate('/');
  };

  const handlePizzaChange = (e: SyntheticEvent) => {
    const pizzaInput = e.target as HTMLInputElement;
    console.log('change in pizzaInput:', pizzaInput.value);
    setPizza(pizzaInput.value);
  };

  const handleDescriptionChange = (e: SyntheticEvent) => {
    const descriptionInput = e.target as HTMLInputElement;
    console.log('change in descriptionInput:', descriptionInput.value);
    setDescription(descriptionInput.value);
  };

  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      setImage(e.target.files[0]);
    }
  };

  return (
    <Box
      sx={{
        margin: 2,
        padding: 3,
        backgroundColor: 'secondary.light',
        borderRadius: 4,
        boxShadow: 2,
      }}
    >
      <form onSubmit={handleSubmit}>
        <Box sx={{ marginBottom: 2 }}>
          <TextField
            fullWidth
            id="pizza"
            name="pizza"
            label="Pizza"
            variant="outlined"
            value={pizza}
            onChange={handlePizzaChange}
            required
            color="primary"
            sx={{
              input: { color: theme.palette.secondary.contrastText },
            }}
          />
        </Box>
        <Box sx={{ marginBottom: 2 }}>
          <TextField
            fullWidth
            id="description"
            name="description"
            label="Description"
            variant="outlined"
            value={description}
            onChange={handleDescriptionChange}
            required
            color="primary"
            sx={{
              input: { color: theme.palette.secondary.contrastText },
            }}
          />
        </Box>
        <Box sx={{ marginBottom: 2 }}>
          <TextField
            fullWidth
            id="image"
            name="image"
            type="file"
            slotProps={{ htmlInput: { accept: 'image/*' } }}
            variant="outlined"
            required
            color="primary"
            onChange={handleImageChange}
          />
        </Box>
        <Button type="submit" variant="contained" color="primary">
          Ajouter
        </Button>
      </form>
    </Box>
  );
};

export default AddPizza;
```

Voici les explications sur ces modifications :
- **`const [image, setImage] = useState<File | undefined>(undefined)`** : crée un état pour stocker l'image sélectionnée par l'utilisateur. L'état initial est **`undefined**.
- **`const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => { ... }`** : est une fonction qui est appelée lorsque l'utilisateur sélectionne une image. Elle récupère le fichier image sélectionné par l'utilisateur et le stocke dans l'état **`image`**.
- **`<TextField ... type="file" slotProps={{ htmlInput: { accept: 'image/*' } }} ... />`** : crée un champ de formulaire pour sélectionner une image. Le type du champ est **`file`**. L'attribut **`accept`** est utilisé pour restreindre les types de fichiers qui peuvent être sélectionnés. Ici, nous restreignons les types de fichiers à ceux de type image.
- **`<TextField ... onChange={handleImageChange} ... />`** : appelle la fonction **`handleImageChange`** lorsque l'utilisateur sélectionne une image.

Il faut aussi mettre à jour la définition du type **`Pizza`** dans **`/frontend/src/types.ts`** :

```ts {5-6}
interface Pizza {
  id: number;
  title: string;
  content: string;
  image?: File | undefined;
  imageLocation?: string | undefined;
}
```

Nous devons maintenant mettre à jour la fonction **`addPizza`** qui est définie dans le composant **`App`**.

Pour ce faire, veuillez mettre à jour **`addPizza`** dans le fichier **`/frontend/src/App/index.tsx`** :

```tsx {7-29} showLineNumbers
 const addPizza = async (newPizza: NewPizza) => {
    try {
      if (!authenticatedUser) {
        throw new Error('You must be authenticated to add a pizza');
      }

      const formData = new FormData();

      const pizzaToBeAdded = JSON.parse(JSON.stringify(newPizza));
      delete pizzaToBeAdded.image;

      if (newPizza.image) {
        formData.append('image', newPizza.image);
      }

      formData.append(
        'newPizza',
        new Blob([JSON.stringify(pizzaToBeAdded)], {
          type: 'application/json',
        }),
      );

      const options = {
        method: 'POST',
        body: formData,
        headers: {
          Authorization: authenticatedUser.token,
        },
      };

      const response = await fetch(`${baseUrl}/pizzas`, options); // fetch retourne une "promise" => on attend la réponse

      if (!response.ok)
        throw new Error(
          `fetch error : ${response.status} : ${response.statusText}`,
        );

      const createdPizza = await response.json(); // json() retourne une "promise" => on attend les données

      setPizzas([...pizzas, createdPizza]);
    } catch (err) {
      console.error('AddPizza::error: ', err);
    }
  };
```

Voici les explications sur ces modifications :
- **`const formData = new FormData()`** : crée un objet **`FormData`** pour stocker les données du formulaire multipart.
- **`const pizzaToBeAdded = JSON.parse(JSON.stringify(newPizza))`** : crée une copie de l'objet **`newPizza`**. Nous supprimons le champ **`image`** de l'objet **`pizzaToBeAdded`** car nous l'ajoutons séparément dans le formulaire multipart.
- **`if (newPizza.image) { formData.append('image', newPizza.image); }`** : ajoute le fichier image à l'objet **`formData`**. Le champ **`image`** est ajouté au formulaire multipart.
- **`formData.append('newPizza', new Blob([JSON.stringify(pizzaToBeAdded)], { type: 'application/json' }),)`** : ajoute l'objet **`pizzaToBeAdded`** au formulaire multipart. L'objet **`pizzaToBeAdded`** est converti en chaîne JSON, puis en un objet **`Blob`**. Le champ **`newPizza`** est ajouté au formulaire multipart. Pourquoi ajouter l'objet **`newPizza`** en tant que **`Blob`** ? Parce que le contenu du formulaire multipart doit être un objet **`Blob`**.
- **`const options = { method: 'POST', body: formData, headers: { Authorization: authenticatedUser.token, }, };`** : crée un objet **`options`** pour la requête **`fetch`**. La méthode de la requête est **`POST`**. Le corps de la requête est l'objet **`formData`**. L'en-tête de la requête contient le token d'authentification de l'utilisateur.

## Mise à jour de l'affichage des pizzas

Veuillez mettre à jour le menu des pizzas. Pour ce faire, veuillez modifier **`/frontend/src/components/PizzaMenu/index.tsx`** :

```tsx {10,43,51-58} showLineNumbers
import {
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  useTheme,
  Box,
} from '@mui/material';

import { Pizza } from '../../types';

interface PizzaMenuProps {
  pizzas: Pizza[];
}
const PizzaMenu = ({ pizzas }: PizzaMenuProps) => {
  const theme = useTheme();
  return (
    <TableContainer component={Paper}>
      <Table
        sx={{
          minWidth: 500,
          '& .MuiTableCell-head': {
            backgroundColor: theme.palette.primary.dark,
            color: theme.palette.primary.contrastText,
            fontWeight: 'bold',
          },
          '& .MuiTableCell-body': {
            backgroundColor: theme.palette.primary.light,
            color: 'white',
          },
          '& .MuiTableCell-root': {
            border: `1px solid ${theme.palette.secondary.main} `,
          },
        }}
      >
        <TableHead>
          <TableRow>
            <TableCell>Pizza</TableCell>
            <TableCell>Description</TableCell>
            <TableCell>Image</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {pizzas.map((pizza) => (
            <TableRow key={pizza.id}>
              <TableCell>{pizza.title}</TableCell>
              <TableCell>{pizza.content}</TableCell>
              <TableCell>
                <Box
                  component="img"
                  src={pizza.imageLocation}
                  alt={pizza.title}
                  sx={{ width: '100px' }}
                />
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </TableContainer>
  );
};

export default PizzaMenu;
```

Ici, nous avons ajouté une colonne **`Image`** à la table des pizzas. Pour chaque pizza, nous affichons l'image de la pizza. 

L'URL de l'image de la pizza est stockée dans le champ **`imageLocation`** de l'objet **`Pizza`**. 

Veuillez bien exécutez votre application frontend pour voir les changements.
Tout devrait être fonctionnel et votre application devrait permettre de créer des pizzas avec des images et d'afficher les images des pizzas.

Ainsi, lors de la création d'une pizza, l'utilisateur peut sélectionner une image pour la pizza. L'image est stockée dans le service de stockage d'objets Azure Blob Storage. L'URL de l'image est stockée dans la DB. Lors de l'affichage des pizzas, l'image de chaque pizza est affichée.
Pour l'affichage, c'est le browser, via une balise **`<img>`**, qui va chercher l'image stockée dans le service de stockage d'objets Azure Blob Storage.

# <InternalPageTitle> Comment utiliser le service de stockage dans l'environnement de staging ? </InternalPageTitle>

## Introduction

Dans ce tutoriel, nous allons voir comment configurer le service de stockage d'objets Azure Blob Storage pour l'environnement de staging.

## Configuration de l'API pour l'environnement de staging

Pour configurer l'API pour l'environnement de staging, nous allons ajouter les configurations suivantes dans le fichier **`/api/src/main/resources/application-staging.properties`** :

```properties
azure.blob.service-endpoint=https://imagestorage007.blob.core.windows.net/
azure.blob.sas-token=${AZURE_BLOB_SAS_TOKEN}
azure.blob.container-name=staging

spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
```

Nous avons choisi de stocker les images des pizzas dans un blob container nommé **`staging`** que nous avons créé précédemment. 

Il est de bonne pratique d'utiliser des containers différents pour chaque environnement (dev, staging, prod) pour isoler les données et éviter les conflits.

## Configuration des variables d'environnement

Pour passer le token d'accès partagé pour le service de stockage d'objets Azure Blob Storage, nous pouvons ajouter la propriété **`AZURE_BLOB_SAS_TOKEN`** dans le fichier **`/docker-compose.staging.yml`** et dans le fichier **`/docker-compose.deploy.yml`** :

```properties {5}
    environment:
      - SPRING_DATASOURCE_URL=${SPRING_DATASOURCE_URL}
      - SPRING_DATASOURCE_USERNAME=${SPRING_DATASOURCE_USERNAME}
      - SPRING_DATASOURCE_PASSWORD=${SPRING_DATASOURCE_PASSWORD}
      - AZURE_BLOB_SAS_TOKEN=${AZURE_BLOB_SAS_TOKEN}
```

Est-ce que c'est nécessaire de mettre cette variable d'environnement dans le fichier de configuration de docker compose qui sera exécuté sur Azure Web app ? Non, ce qui compte, c'est de configurer les variables d'environnement dans le portail Azure.  
Néanmoins, il est intéressant de les mettre dans le fichier de configuration pour ces raisons :
- pour pouvoir tester en local.
- pour avoir une trace de toutes les configurations nécessaires pour le déploiement.

## Configuration des variables d'environnement dans le portail Azure

Pour configurer les variables d'environnement dans le portail Azure, veuillez suivre les étapes suivantes.

Au niveau de votre Azure Web App (**`cae-groupxy-staging-app`** par exemple) via le portail Azure, veuillez :
- Cliquer sur **`Settings`**.
- Cliquer sur **`Environment variables`**.
- Ajouter la variable d'environnement suivante en cliquant sur **`Add`** :
  - **`AZURE_BLOB_SAS_TOKEN`** (**`Name`**): une valeur de token qui correspond à ce que vous avez généré précédemment, comme par exemple **`sv=2022-11-02&ss=bfqt&srt=o&sp=rwdlacupiytfx&se=2035-02-24T23:52:15Z&st=2025-02-24T15:52:15Z&spr=https&sig=OoOAYhdQZGxO74hSUHKHgDw1Bvq%2FeSciIift10CMM34%3D`** (**`Value`**). Cliquez sur **`Apply`**.
  - N'oubliez pas de cliquer sur **`Apply`** pour sauvegarder l'ajout de la variable, puis **`Confirm`**.

## Comment lancer un environnement local avec les configurations de staging ?

Pour lancer un environnement local avec les configurations de staging, nous allons utiliser le fichier **`/docker-compose.staging.yml`**.

Pour ce faire, veuillez exécuter la commande suivante :

```bash
docker compose -f docker-compose.staging.yml --env-file api/.env up --build
```

Puis, il suffit de lancer un browser et de se rendre sur http://localhost pour accéder à l'application frontend.


## Comment lancer un environnement de staging sur Azure Web App ?

Pour déployer l'application sur Azure Web App, il suffit de pousser les modifications sur votre projet GitLab. Le pipeline GitLab se chargera de déployer l'application sur Azure Web App.

Pour vérifier que l'application a bien été déployée, veuillez vous rendre sur le portail Azure, puis sur votre Azure Web App (**`cae-groupxy-staging-app`** par exemple).

Vous devriez voir l'application frontend en vous rendant sur l'URL de l'application Azure Web App, par exemple : **`https://cae-groupxy-staging-app.azurewebsites.net`**.

Si nécessaire, vous pouvez trouver le code associé à la gestion des images ici : [images](https://github.com/e-vinci/cae-theory-demos/tree/main/images).

## Conclusion sur la gestion des images avec Azure Stockage pour l'environnement de développement

Nous avons maintenant un nouvel environnement de développement local que nous pouvons visualiser ainsi :

<PlantUML src="/diagrams/local-dev-deployment2.puml" alt="Environnement de développement"/>

Pas tous les éléments de notre environnement de développement sont locaux. En effet, nous avons un service de stockage d'objets Azure Blob Storage qui est utilisé pour stocker les images des pizzas. Cela nous permet de tester le stockage des images dans un environnement similaire à celui de production.

🍬 Si vous préfériez, pour votre environnement de développement uniquement, vous pourriez utiliser un serveur de fichiers statiques pour stocker les images. Cela vous permettrait de ne pas dépendre d'un service de stockage d'objets externe. Vous pourriez stocker les images dans un dossier local de votre API Spring. Nous ne verrons pas cela dans le cadre de ce cours, donc n'hésitez pas à explorer par vous-même.

## Conclusion sur la gestion des images avec Azure Stockage pour l'environnement de staging

Nous avons maintenant un nouvel environnement de staging que nous pouvons visualiser ainsi :

<PlantUML src="/diagrams/staging-deployment2.puml" alt="Environnement de staging"/>

Nous avons configuré l'API pour stocker les images des pizzas dans un blob container nommé **`staging`** dans le service de stockage d'objets Azure Blob Storage. 

Tout devrait être fonctionnel et votre application devrait permettre de créer des pizzas avec des images et d'afficher les images des pizzas dans l'environnement de staging.

Prochainement, nous allons voir comment faire un déploiement en production.

