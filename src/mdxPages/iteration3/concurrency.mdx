---
title: Concurrence
description: Gestion de la concurrence
date: 24/03/2025
---

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> CAE </PathViewerItem>
    <PathViewerItem to="/iteration3"> It√©ration 3 </PathViewerItem>
    <PathViewerItem selected> Gestion de la concurrence </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Pourquoi g√©rer la concurrence ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment g√©rer la concurrence ? </InternalPageMenuItem>
  <InternalPageMenuItem> Optimistic Locking dans Spring Boot </InternalPageMenuItem>
  <InternalPageMenuItem> Pessimistic Locking dans Spring Boot </InternalPageMenuItem>
  <InternalPageMenuItem> Comment g√©rer des transactions dans Spring Boot ? </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Pourquoi g√©rer la concurrence ? </InternalPageTitle>

La concurrence est un sujet important en informatique. En effet, de nombreux probl√®mes peuvent survenir si la concurrence n'est pas g√©r√©e correctement. Par exemple, si deux processus essaient de modifier la m√™me donn√©e en m√™me temps, il peut y avoir des probl√®mes de coh√©rence des donn√©es.

Prenons l'exemple d'une application o√π l'on g√®re un stock de produits. Si deux utilisateurs essaient de modifier la quantit√© d'un produit en m√™me temps, il peut y avoir des probl√®mes de coh√©rence des donn√©es. Par exemple, si un utilisateur essaie d'ajouter 5 unit√©s √† la quantit√© d'un produit, et qu'un autre utilisateur essaie de retirer 3 unit√©s du m√™me produit en m√™me temps, il peut y avoir des probl√®mes de coh√©rence des donn√©es.

NB : La concurrence pourrait entra√Æner des probl√®mes de performance si elle n'est pas g√©r√©e correctement. Par exemple, si plusieurs processus essaient d'acc√©der √† la m√™me ressource en m√™me temps, il peut y avoir des probl√®mes de latence et de ralentissement. N√©anmoins, nous ne devons g√©n√©ralement pas g√©rer ce type de probl√®me car cela est automatiquement trait√© par les frameworks que nous utilisons. En effet, en cas de multiples requ√™tes sur une m√™me ressource, le framework Spring Boot g√®re cela en cr√©ant un pool de threads pour traiter les requ√™tes. Comment √ßa fonctionne ?  
Lorsqu'une requ√™te HTTP arrive, un thread est extrait du pool pour traiter cette requ√™te.  
Une fois la requ√™te trait√©e, le thread est remis dans le pool pour √™tre r√©utilis√©.  
Cela permet de limiter le nombre de threads actifs et d'√©viter de cr√©er un nouveau thread pour chaque requ√™te, ce qui serait co√ªteux en termes de performances.

# <InternalPageTitle> Comment g√©rer la concurrence ? </InternalPageTitle>

## Introduction

Il existe plusieurs fa√ßons de g√©rer la concurrence en informatique. Voici quelques-unes des techniques les plus courantes :
- **Optimistic Locking** : Cette technique consiste √† v√©rifier si la donn√©e a √©t√© modifi√©e par un autre processus avant de la modifier. Si la donn√©e a √©t√© modifi√©e, une exception est lev√©e et le processus doit g√©rer cette exception.
- **Pessimistic Locking** : Cette technique consiste √† verrouiller la donn√©e avant de la modifier. Cela garantit qu'aucun autre processus ne peut modifier la donn√©e tant que le verrou n'est pas lib√©r√©.
- **Transactions** : Les transactions sont un moyen de regrouper plusieurs op√©rations sur une base de donn√©es en une seule unit√© logique. Cela garantit que toutes les op√©rations sont ex√©cut√©es de mani√®re atomique, c'est-√†-dire que toutes les op√©rations sont ex√©cut√©es ou aucune op√©ration n'est ex√©cut√©e. Les transactions sont particuli√®rement utiles pour garantir la coh√©rence des donn√©es dans des sc√©narios de concurrence, sans pour autant r√©gler les probl√®mes de concurrence en eux-m√™mes.
- **V√©rous distribu√©s** : Les verrous distribu√©s sont des verrous qui peuvent √™tre utilis√©s pour coordonner l'acc√®s √† une ressource partag√©e entre plusieurs processus. Redis peut √™tre utilis√© pour ce genre d'applications. Des verrous peuvent √™tre utilis√©s pour garantir que seuls un certain nombre de processus peuvent acc√©der √† la ressource en m√™me temps. Cela est particuli√®rement utile dans des architectures distribu√©es, type microservices, o√π plusieurs instances doivent g√©rer une ressource partag√©e. Nous n'aborderons pas ce sujet dans ce cours, car notre application n'est pas distribu√©e.
- **File de messages** : Une file de messages (comme RabbitMQ ou Kafka) peut √™tre utilis√©e pour g√©rer la concurrence. Les messages sont envoy√©s √† une file, puis trait√©s par un ou plusieurs consommateurs. Cela permet de g√©rer la concurrence en s√©parant la production de la consommation de messages. Ce type de solution est particuli√®rement utile dans des architectures distribu√©es, o√π plusieurs instances doivent traiter des messages en parall√®le. Nous n'aborderons pas ce sujet dans ce cours.

# <InternalPageTitle> Optimistic Locking dans Spring Boot </InternalPageTitle>


## Introduction

L'optimistic locking repose sur l'id√©e que les conflits sont rares. Avant de mettre √† jour une donn√©e, on v√©rifie si elle a √©t√© modifi√©e par un autre processus en utilisant un champ de version.

L'optimistic locking est id√©al pour les sc√©narios o√π les conflits sont peu fr√©quents, comme la mise √† jour d'un nom de produit ou la mise √† jour d'une quantit√© en stock, lorsque le stock est modifiable par un nombre limit√© d'utilisateurs.

L'int√©r√™t de l'optimistic locking est qu'il n'y a pas de verrouillage de la ressource, ce qui permet √† plusieurs processus de lire la ressource en m√™me temps. Cela am√©liore les performances de l'application. Cependant, si un conflit survient, il faut g√©rer l'exception lev√©e par la base de donn√©es.

## Bases pour l'optimistic locking

Voici un exemple d'optimistic locking en Java avec JPA :

```java {11,19,29} showLineNumbers
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private int quantity;

    @Version
    private int version; // Champ utilis√© pour l'optimistic locking

    // Getters et setters
}

// Partie du service pour mettre √† jour le stock d'un produit

@Transactional
public void updateStock(Long productId, int quantityToRemove) {
    Product product = productRepository.findById(productId)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));
    
    if(product.getQuantity() < quantityToRemove) {
        throw new RuntimeException("Stock insuffisant");
    }

    product.setQuantity(product.getQuantity() - quantityToRemove);
    productRepository.save(product); // V√©rifie automatiquement la version
}
```

Dans cet exemple, le champ **`version`** est utilis√© pour l'optimistic locking. Lorsque la m√©thode `save` est appel√©e, JPA v√©rifie automatiquement si la version de l'entit√© en base de donn√©es correspond √† la version de l'entit√© en m√©moire. Si ce n'est pas le cas, une exception **`OptimisticLockException`** est lev√©e.

**`@Transactional`** : Cette annotation permet de d√©finir une m√©thode comme transactionnelle. Cela signifie que toutes les op√©rations effectu√©es dans cette m√©thode seront regroup√©es en une seule transaction. Ici, comme il n'y a qu'une seule op√©ration (la mise √† jour du stock), l'annotation **`@Transactional`** n'est pas strictement n√©cessaire, mais elle est recommand√©e pour des raisons de clart√©.  
En effet, si vous ajoutez d'autres op√©rations de modification dans cette m√©thode, elles seront automatiquement incluses dans la transaction.

Ici l'on v√©rifie la version de l'entit√© en base de donn√©es au moment de la sauvegarde. Cela est suffisant pour g√©rer les conflits dans le cadre d'une op√©ration transactionnelle unique, si l'on imaginait que deux utilisateurs essaient de modifier la quantit√© d'un produit en m√™me temps. 

> Attention : Le code donn√© pour l'optimistic locking dans l'exemple ci-dessus fonctionne bien dans le cadre d'une op√©ration transactionnelle unique, o√π la version est v√©rifi√©e au moment de l'ex√©cution de la m√©thode **`updateStock`**. Cependant, dans le contexte d'une API RESTful, o√π les appels sont effectu√©s par des clients distincts (par exemple, deux requ√™tes HTTP s√©par√©es), ce code ne couvre pas le cas o√π la version doit √™tre v√©rifi√©e entre deux requ√™tes clientes, lorsqu'il y a une op√©ration de lecture suivie d'une op√©ration de mise √† jour. Nous verrons comment g√©rer ce cas dans la section suivante.



## Optimistic locking dans une API RESTful avec lecture suivie d'une mise √† jour

### Introduction

Dans une API RESTful, il est courant que le client effectue une requ√™te **`GET`** pour r√©cup√©rer une ressource, puis une requ√™te **`PUT`** ou **`PATCH`** pour la mettre √† jour. Dans ce cas, il est n√©cessaire de v√©rifier que la version de la ressource n'a pas chang√© entre les deux requ√™tes.

Par exemple, si l'on veut assurer que deux clients ne modifient pas en m√™me temps le nom d'un produit, on doit v√©rifier que la version du produit n'a pas chang√© entre la lecture et la mise √† jour. Car si un client lit le produit, puis un autre client modifie le produit, le premier client pourrait √©craser les modifications du second client sans le savoir.

### Exemple concret 

1. Ajouter le champ **`@Version`** dans l'entit√©  
Le champ **`@Version`** est utilis√© pour g√©rer l'optimistic locking. JPA v√©rifie automatiquement ce champ lors de la sauvegarde.


```java {11} showLineNumbers
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private int quantity;

    @Version
    private int version; // Champ utilis√© pour l'optimistic locking

    // Getters et setters
}
```



2. Lecture de la ressource avec la version (GET)  
Lorsqu'un client r√©cup√®re une ressource, incluez la version dans la r√©ponse pour qu'il puisse l'utiliser lors de la mise √† jour.

```java {15} showLineNumbers
@GetMapping("/products/{id}")
public ProductDTO getProduct(@PathVariable Long id) {
    Product product = productRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));

    return new ProductDTO(product.getId(), product.getName(), product.getQuantity(), product.getVersion());
}

// Code pour l'op√©ration de lecture d'un produit
@GetMapping("/products/{id}")
public ProductDTO getProduct(@PathVariable Long id) {
    Product product = productRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));

    return new ProductDTO(product.getId(), product.getName(), product.getQuantity(), product.getVersion());
}
```

3. Mise √† jour de la ressource avec v√©rification de la version (PUT)  
Lors de la mise √† jour, le client doit inclure la version qu'il a re√ßue dans la requ√™te. Si cette version ne correspond pas √† la version actuelle de la ressource, on d√©cide de lever une exception **`OptimisticLockException`** seulement si le nom du produit a √©t√© mis √† jour.  
De plus, JPA effectue automatiquement la v√©rification de la version si le champ **`@Version`** est pr√©sent dans l'entit√© et que vous utilisez une m√©thode comme **`save()`** pour persister l'entit√©. Lorsque vous appelez **`productRepository.save(product)`**, JPA compare la version de l'entit√© en m√©moire avec celle en base de donn√©es.  
Si elles ne correspondent pas (par exemple, si un autre client a modifi√© la ressource entre-temps), une exception **`OptimisticLockException`** est aussi lev√©e.

```java {13-17} showLineNumbers
// Code pour l'op√©ration de mise √† jour d'un produit
@Transactional
@PutMapping("/products/{id}")
public ResponseEntity<Void> updateProduct(@PathVariable Long id, @RequestBody UpdateProductRequest request) {
    Product product = productRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));

    if(product.getQuantity() < request.getQuantityToRemove()) {
        throw new RuntimeException("Stock insuffisant");
    }

    // V√©rification explicite de la version 
    if (!product.getVersion().equals(request.getVersion())) {
      if(!product.getName().equals(request.getName())) {
        throw new OptimisticLockException("Conflit de version d√©tect√© lors du changement de nom");
      }
    }

    // Mise √† jour du nom
    product.setName(request.getName());

    // Mise √† jour de la quantit√©
    product.setQuantity(product.getQuantity() + request.getQuantityToRemove());
    productRepository.save(product);

    return ResponseEntity.noContent().build();
}

// Code pour UpdateProductRequest
public class UpdateProductRequest {
    private string name;
    private int quantityToRemove;
    private int version; // Version re√ßue lors de la lecture

    // Getters et setters
}
```

4. Gestion des conflits  


```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(OptimisticLockException.class)
    public ResponseEntity<String> handleOptimisticLockException(OptimisticLockException ex) {
        return ResponseEntity.status(HttpStatus.CONFLICT).body("Conflit de version d√©tect√©");
    }
}
```

En cas de conflit de version, le gestionnaire global d'exceptions renvoie une r√©ponse **`409 Conflict`** au client.  

Le client peut alors g√©rer ce cas en r√©cup√©rant √† nouveau la ressource, en affichant un message √† l'utilisateur ou en effectuant une autre action appropri√©e.  
Notamment, en cas de tentative de modification du nom du produit, le client peut afficher un message √† l'utilisateur pour l'informer du conflit et lui demander de confirmer la modification.

Il faudrait bien s√ªr adapter ce code √† votre application, en fonction de vos besoins et de votre architecture. Par exemple, vous pourriez ajouter un champs pour g√©rer la confirmation de la modification du nom du produit, ou ajouter des informations suppl√©mentaires dans la r√©ponse pour aider le client √† g√©rer le conflit.

## En savoir plus

Si vous souhaitez en savoir plus sur l'optimistic locking, vous pouvez consulter cet article : https://www.baeldung.com/jpa-optimistic-locking

# <InternalPageTitle> Pessimistic Locking dans Spring Boot </InternalPageTitle>

## Introduction

Le pessimistic locking repose sur l'id√©e que les conflits sont fr√©quents. Avant de mettre √† jour une donn√©e, on verrouille la ressource pour emp√™cher tout autre processus de la modifier.

Le pessimistic locking est id√©al pour les sc√©narios o√π les conflits sont fr√©quents, comme la mise √† jour d'un stock de produits lorsque le stock peut √™tre modifi√© par √©norm√©ment d'utilisateurs en m√™me temps.

## Bases pour le pessimistic locking

Voici un exemple de pessimistic locking en Java avec JPA :

```java {2,15} showLineNumbers
// Partie du service pour mettre √† jour le stock d'un produit
@Transactional
public void updateStockWithPessimisticLock(Long productId, int quantityToAdd) {
    Product product = productRepository.findByIdWithLock(productId)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));

    product.setQuantity(product.getQuantity() + quantityToAdd);
    productRepository.save(product);
}

// Repository

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    Optional<Product> findById(Long productId);
}
```

Avec JPA, vous pouvez utiliser **`@Lock`** directement sur la m√©thode **`findById`** pour appliquer un verrou pessimiste sans avoir besoin d'une requ√™te personnalis√©e.

**`@Lock(LockModeType.PESSIMISTIC_WRITE)`** : Cette annotation permet d'appliquer un verrou pessimiste en √©criture sur la ressource. Cela signifie que la ressource est verrouill√©e pour emp√™cher tout autre processus de la modifier.

Dans cet exemple, le verrou pessimiste est appliqu√© lors de la recherche du produit √† mettre √† jour. Cela garantit qu'aucun autre processus ne peut modifier le produit tant que le verrou n'est pas lib√©r√©. A quel moment le verrou est-il lib√©r√© ? Le verrou est g√©n√©ralement lib√©r√© √† la fin de la transaction, c'est-√†-dire lorsque la m√©thode annot√©e avec **`@Transactional`** se termine.

Que se passe-t-il si un autre processus essaie de lire ou de modifier la ressource verrouill√©e ? Imaginons que 10 utilisateurs essaient de mettre √† jour le stock d'un produit en m√™me temps. Le premier utilisateur obtient le verrou et met √† jour le stock. Les 9 autres utilisateurs attendent que le verrou soit lib√©r√©. Une fois que le premier utilisateur a termin√©, le verrou est lib√©r√© et un des 9 autres utilisateurs obtient le verrou et met √† jour le stock. Les 8 autres utilisateurs attendent, et ainsi de suite.

## Probl√®me √©ventuel de performance 

Le pessimistic locking peut entra√Æner des probl√®mes de performance si les verrous sont maintenus trop longtemps. Par exemple, si un utilisateur obtient un verrou et met √† jour le stock, mais ne termine pas l'op√©ration, le verrou est maintenu et les autres utilisateurs doivent attendre. Cela peut entra√Æner des probl√®mes de latence et de ralentissement.

Heureusement, si une exception est lev√©e, gr√¢ce √† la transaction **`@Transactional`**, le verrou est automatiquement lib√©r√©. 

Pour √©viter que les verrous ne soient maintenus trop longtemps, il est recommand√© de limiter la dur√©e des transactions en ajoutant un timeout. Par exemple, vous pouvez ajouter une annotation **`@Transactional(timeout = 10)`** pour limiter la dur√©e de la transaction √† 10 secondes. Si la transaction ne se termine pas dans les 10 secondes, une exception est lev√©e et le verrou est lib√©r√©.

Comment s'appelle l'exception lev√©e en cas de timeout ? L'exception lev√©e en cas de timeout est une **`TransactionTimedOutException`**. Cette exception est lev√©e si la transaction ne se termine pas dans le d√©lai imparti.

Voici notre exemple de pessimistic locking avec un timeout :

```java {1} showLineNumbers
@Transactional(timeout = 10)
public void updateStockWithPessimisticLock(Long productId, int quantityToAdd) {
    Product product = productRepository.findByIdWithLock(productId)
            .orElseThrow(() -> new RuntimeException("Produit non trouv√©"));

    product.setQuantity(product.getQuantity() + quantityToAdd);
    productRepository.save(product);
}

// Repository

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    Optional<Product> findById(Long productId);
}

```

## En savoir plus

Si vous souhaitez en savoir plus sur le pessimistic locking, vous pouvez consulter cet article : https://www.baeldung.com/jpa-pessimistic-locking

# <InternalPageTitle> Comment g√©rer des transactions dans Spring Boot ? </InternalPageTitle>

## Introduction

Les transactions sont un moyen de regrouper plusieurs op√©rations en une seule unit√© logique. Cela garantit que toutes les op√©rations sont ex√©cut√©es de mani√®re atomique, c'est-√†-dire que toutes les op√©rations sont ex√©cut√©es ou aucune op√©ration n'est ex√©cut√©e.

Avec Spring Boot, vous pouvez g√©rer les transactions en utilisant l'annotation **`@Transactional`**. Cette annotation permet de d√©finir une m√©thode comme transactionnelle. Cela signifie que toutes les op√©rations sur la base de donn√©es effectu√©es dans cette m√©thode seront regroup√©es en une seule transaction.

Par exemple, si vous souhaitez ajouter une adresse √† un utilisateur, vous devez ajouter l'adresse et mettre √† jour l'utilisateur en m√™me temps. Si l'une des op√©rations √©choue, vous ne voulez pas que l'autre op√©ration soit ex√©cut√©e. Les transactions garantissent que les deux op√©rations sont ex√©cut√©es ensemble.

Les transactions ne r√®glent pas les probl√®mes de concurrence, mais coupl√© √† l'optimistic ou pessimistic locking, elles permettent de g√©rer les conflits de mani√®re plus robuste.

## Bases pour les transactions

Voici un exemple de transaction en Java avec Spring Boot, lorsque nous avons un repository pour les utilisateurs et un repository pour les adresses.

Voici les entit√©s :

```java {} showLineNumbers
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "address_id", referencedColumnName = "id")
    private Address address;

    // Getters et setters
}

@Entity
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true) // Emp√™che les doublons d'adresses
    private String street;

    private String city;

    private String postalCode;

    // Getters et setters
}
```


Voici les repositories :

```java {} showLineNumbers
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
}
```

Voici les DTO pour les requ√™tes :

```java {} showLineNumbers
public class UserDTO {
    private String name;
    private AddressDTO address;

    // Getters et setters
}

public class AddressDTO {
    private String street;
    private String city;
    private String postalCode;

    // Getters et setters
}
```

Voici le contr√¥leur :

```java {} showLineNumbers
@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping
    public User addUserWithAddress(@RequestBody UserDTO userDTO) {
        return userService.addUserWithAddress(userDTO);
    }
}
```

Voici l'exception que nous souhaitons lancer pour une adresse d√©j√† existante :

```Java
public class AddressAlreadyExistsException extends RuntimeException {
    public AddressAlreadyExistsException(String message) {
        super(message);
    }
}
```

Voici un service pour ajouter une adresse et un utilisateur :

```java {12} showLineNumbers
@Service
public class UserService {

    private final UserRepository userRepository;
    private final AddressRepository addressRepository;

    public UserService(UserRepository userRepository, AddressRepository addressRepository) {
        this.userRepository = userRepository;
        this.addressRepository = addressRepository;
    }

    @Transactional
    public User addUserWithAddress(UserDTO userDTO) {
        // V√©rifier si l'adresse existe d√©j√†
        Optional<Address> existingAddress = addressRepository.findByStreetAndCityAndPostalCode(
                userDTO.getAddress().getStreet(),
                userDTO.getAddress().getCity(),
                userDTO.getAddress().getPostalCode()
        );

        if (existingAddress.isPresent()) {
            throw new AddressAlreadyExistsException("L'adresse existe d√©j√† !");
        }

        // Sauvegarder l'adresse
        Address address = new Address();
        address.setStreet(userDTO.getAddress().getStreet());
        address.setCity(userDTO.getAddress().getCity());
        address.setPostalCode(userDTO.getAddress().getPostalCode());
        addressRepository.save(address);

        // Sauvegarder l'utilisateur
        User user = new User();
        user.setName(userDTO.getName());
        user.setAddress(address);
        return userRepository.save(user); // Retourner l'utilisateur sauvegard√©
    }
}
```

> Ici la gestion des transactions est assur√©e par l'annotation **`@Transactional`** sur la m√©thode **`addUserWithAddress`**. Cela signifie que toutes les op√©rations effectu√©es dans cette m√©thode seront regroup√©es en une seule transaction. Cela garantit que toutes les op√©rations sont ex√©cut√©es de mani√®re atomique, c'est-√†-dire que toutes les op√©rations sont ex√©cut√©es ou aucune op√©ration n'est ex√©cut√©e.

üí≠ Peux-tu imaginer une autre raison pour que JPA √©choue √† sauvegarder l'adresse ?  
Normalement, JPA ne devrait pas √©chouer √† sauvegarder l'adresse, car normalement, dans le contr√¥leur, on est cens√© valider tous les param√®tres avant d'appeler le service.  

Une fois l'adresse sauvegard√©e, on pourrait imaginer que l'on ne peut pas sauvegarder l'utilisateur. Par exemple, si l'utilisateur a d√©j√† √©t√© sauvegard√©, on ne peut pas le sauvegarder √† nouveau.  
L'avantage de la transaction est que si l'une des op√©rations √©choue, l'autre op√©ration ne sera pas ex√©cut√©e. Cela garantit que les donn√©es restent coh√©rentes.  
Bien s√ªr, pour rendre le code plus robuste et clair, il faudrait aussi v√©rifier si l'utilisateur existe d√©j√† avant de le sauvegarder.

Et finalement, voici le gestionnaire global d'exceptions pour l'exception **`AddressAlreadyExistsException`** :

```java {} showLineNumbers
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(AddressAlreadyExistsException.class)
    public void handleAddressAlreadyExistsException(AddressAlreadyExistsException ex) {
        throw new ResponseStatusException(HttpStatus.CONFLICT, ex.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public void handleGenericException(Exception ex) {
        throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Une erreur est survenue : " + ex.getMessage());
    }
}
```

Ici, le gestionnaire global d'exceptions renvoie une r√©ponse **`409 Conflict`** au client en cas d'exception **`AddressAlreadyExistsException`**. Cela signifie que si l'adresse existe d√©j√†, le client recevra une r√©ponse **`409 Conflict`**.

## En savoir plus

Si vous souhaitez en savoir plus sur les transactions avec Spring Boot, vous pouvez consulter cet article : https://docs.spring.io/spring-framework/reference/data-access/transaction.html