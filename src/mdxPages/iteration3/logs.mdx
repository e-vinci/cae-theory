---
title: Logs
description: Gestion des logs et des erreurs
date: 12/03/2025
---

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> CAE </PathViewerItem>
    <PathViewerItem to="/iteration3"> It√©ration 3 </PathViewerItem>
    <PathViewerItem selected> Gestion des logs et des erreurs </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Pourquoi g√©rer des logs ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment g√©rer les exceptions dans une application Spring Boot ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment g√©rer les exceptions de Spring Boot comme AccessDeniedException ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment logguer les exceptions de mani√®re centralis√©e ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment visualiser les logs dans l'environnement d√©ploy√© ? </InternalPageMenuItem>
  <InternalPageMenuItem> Utiliser Azure Monitor pour visualiser les logs en temps r√©el </InternalPageMenuItem>
</InternalPageMenu>

# <InternalPageTitle> Pourquoi g√©rer des logs ? </InternalPageTitle>

## Introduction

Lorsqu'une application est en production, les logs sont essentiels pour comprendre les erreurs qui se produisent et pour les corriger rapidement. Ils permettent √©galement de suivre les performances de l'application et de d√©tecter les probl√®mes potentiels.

Les logs doivent √™tre clairs, concis et informatifs. Ils doivent contenir suffisamment d'informations pour permettre de comprendre l'erreur et de la corriger, mais ne pas √™tre trop verbeux pour ne pas noyer l'op√©rateur d'informations inutiles.

Les logs doivent permettre de r√©pondre √† plusieurs questions :
- Quand l'erreur s'est-elle produite ?
- O√π l'erreur s'est-elle produite ?
- Qui a provoqu√© l'erreur ?
- Quelle est la nature de l'erreur ?
- Comment l'erreur peut-elle √™tre corrig√©e ?

Ces questions doivent √™tre prises en compte lors de la r√©daction des logs. Cela permettra de faciliter le travail d'investigation et de correction des erreurs par les d√©veloppeurs.

## Types de logs

Il existe plusieurs types de logs, en fonction de leur gravit√© et de leur importance. Voici quelques exemples de types de logs courants :
- **DEBUG** : Informations de d√©bogage, utiles pour comprendre le fonctionnement interne de l'application.
- **INFO** : Informations g√©n√©rales sur le fonctionnement de l'application.
- **WARN** : Avertissements sur des situations potentiellement probl√©matiques.
- **ERROR** : Erreurs qui ont emp√™ch√© le bon fonctionnement de l'application.
- **FATAL** : Erreurs graves qui ont provoqu√© l'arr√™t de l'application. Il est √† noter que la librairie **Logback** (librairie par d√©faut pour une application Spring Boot) ne supporte pas ce niveau de log. **FATAL** est donc souvent remplac√© par **ERROR**.
- **TRACE** : Informations d√©taill√©es sur le fonctionnement de l'application, utiles pour le d√©bogage.

Il est important de choisir le bon type de log en fonction de la gravit√© de l'erreur. Les logs de type DEBUG ne doivent pas √™tre activ√©s en production, car ils peuvent contenir des informations sensibles sur le fonctionnement interne de l'application.

Quelle diff√©rence entre un log de type **`TRACE`** et un log de type **`DEBUG`** ? Le log de type **`TRACE`** est plus d√©taill√© que le log de type **`DEBUG`**. Le log de type **`TRACE`** est utilis√© pour des informations tr√®s d√©taill√©es sur le fonctionnement de l'application, utiles pour le d√©bogage. Le log de type **`DEBUG`** est utilis√© pour des informations de d√©bogage, utiles pour comprendre le fonctionnement interne de l'application.

## Quels services sont √† logguer ?

Au sein de notre application d'entreprise, l'API Spring Boot qui g√®re les requ√™tes HTTP des clients doit √™tre loggu√©e pour suivre les erreurs et les performances.

Est-ce que le frontend doit √™tre loggu√© ? Non, car le frontend est une application statique qui ne n√©cessite pas de logs. Les erreurs du frontend peuvent √™tre suivies via les outils de d√©veloppement du navigateur. D'autre part, les d√©veloppeurs n'ont pas acc√®s aux logs du navigateur des utilisateurs, ce qui rend difficile le suivi des erreurs c√¥t√© client.

Est-ce que la base de donn√©es doit √™tre loggu√©e ? Oui, car les erreurs de connexion √† la base de donn√©es peuvent √™tre critiques pour le bon fonctionnement de l'application. Les logs de la base de donn√©es doivent √™tre activ√©s pour suivre les erreurs de connexion et les requ√™tes SQL. N√©anmoins, les logs de la base de donn√©es ne doivent pas contenir d'informations sensibles, comme les mots de passe. De plus, comme nous utilisons Spring Data JPA, les logs de la base de donn√©es sont g√©n√©r√©s automatiquement par Hibernate, il n'y a donc rien √† faire au niveau de la base de donn√©es, seulement au niveau de l'API.

Est-ce que Docker doit √™tre loggu√© ? Oui, car les erreurs de d√©ploiement et de configuration de Docker peuvent √™tre critiques pour le bon fonctionnement de l'application. Les logs de Docker doivent √™tre activ√©s pour suivre les erreurs de d√©ploiement et de configuration. De plus, les logs de Docker peuvent √™tre utiles pour suivre les performances des conteneurs et d√©tecter les probl√®mes potentiels.

## Comment g√©rer les logs des exceptions ?

Les exceptions doivent √™tre loggu√©es de mani√®re appropri√©e pour permettre de comprendre l'erreur et de la corriger rapidement. Mais attention, nous ne souhaitons pas polluer le code avec des **`try-catch`** un peu partout.

Avant de continuer dans la gestion des logs, nous allons donc voir les bonnes pratiques pour g√©rer les exceptions dans une application Spring Boot.

# <InternalPageTitle> Comment g√©rer les exceptions dans une application Spring Boot ? </InternalPageTitle>

## Introduction

Il est important de g√©rer correctement les exceptions dans une application Spring Boot pour garantir un comportement fiable et pr√©visible. Les exceptions peuvent survenir √† tout moment pendant l'ex√©cution de l'application et doivent √™tre trait√©es de mani√®re appropri√©e pour √©viter les plantages et les comportements inattendus.

De plus, il existe des bonnes pratiques pour g√©rer les exceptions afin d'√©viter de polluer le code avec des **`try-catch`** inutiles et de garantir une gestion coh√©rente des erreurs.

Et finalement, avec Spring Boot, il y a beaucoup de parties de code qui g√©n√®rent d√©j√† des exceptions sans que cela soit directement visible dans le code. Nous pensons ici notamment aux erreur de base de donn√©es (via les repositories), aux erreurs d'authentification (via Spring Security), etc...   
Il est donc important de savoir comment g√©rer ces exceptions de mani√®re centralis√©e.


## Gestion actuelle des exceptions via ResponseStatusException

Dans notre application actuelle, nous utilisons la classe **`ResponseStatusException`** pour g√©rer les exceptions et renvoyer des r√©ponses HTTP appropri√©es aux clients. Cette classe permet de sp√©cifier le code de statut HTTP √† renvoyer ainsi que le message d'erreur √† afficher.

En voici un exemple : 

```java {11}
  /**
   * Get a pizza by id.
   *
   * @param id the pizza id.
   * @return the pizza.
   */
  @GetMapping("/{id}")
  public Pizza getPizza(@PathVariable long id) {
    Pizza pizza = pizzaService.getPizza(id);
    if (pizza == null) {
      throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Pizza not found");
    }
    return pizza;
  }
```

Dans cet exemple, si la pizza n'est pas trouv√©e, une exception de type **`ResponseStatusException`** est lanc√©e avec le code de statut HTTP **`404 NOT FOUND`** et le message d'erreur **`Pizza not found`**.

Est-ce que cette exception est loggu√©e automatiquement ? Non, les exception de type **`ResponseStatusException`** ne sont pas loggu√©es automatiquement par Spring Boot. Il est donc n√©cessaire de les logguer manuellement pour suivre les erreurs de mani√®re coh√©rente. Nous allons voir √ßa tout prochainement.

Cette approche est simple et efficace pour g√©rer les exceptions et renvoyer des r√©ponses HTTP appropri√©es aux clients. Cependant, elle ne permet pas de logguer les exceptions de mani√®re centralis√©e et de suivre les erreurs de mani√®re coh√©rente.

> **Notions d'architecture importantes** : Les exceptions de type **`ResponseStatusException`** sont des exceptions sp√©cifiques √† Spring Boot qui permettent de renvoyer des r√©ponses HTTP avec un code de statut et un message d'erreur. Elles font partie de la couche de pr√©sentation de l'API et sont g√©n√©ralement utilis√©es pour renvoyer des r√©ponses aux clients. Ces exceptions ne doivent donc pas se trouver dans la couche "business" de l'application, c'est-√†-dire dans les services ou les repositories. Elles peuvent √™tre utilis√©es dans les contr√¥leurs pour renvoyer des r√©ponses HTTP aux clients, ou dans les filtres pour intercepter les requ√™tes et les r√©ponses.

## Gestion d'exceptions personnalis√©es

Pour g√©rer les exceptions de mani√®re centralis√©e et coh√©rente, il est recommand√© d'utiliser des exceptions personnalis√©es. Ces exceptions peuvent √™tre √©tendues √† partir de la classe **`RuntimeException`** ou de l'une de ses sous-classes, comme **`IllegalArgumentException`** ou **`IllegalStateException`**.

Si l'on reprend l'exemple pr√©c√©dent, nous pourrions cr√©er une exception personnalis√©e **`ResourceNotFoundException`** pour g√©rer les cas o√π une ressource n'est pas trouv√©e. Cela nous permettra d'avoir une gestion plus globale des exceptions, nous pourrons utiliser la m√™me exception dans plusieurs parties de l'application, car en fait, cela n'est pas vraiment utile dans le message renvoy√© au client de pr√©ciser que la pizza n'a pas √©t√© trouv√©e. C'est g√©n√©ralement √©vident que si une op√©ration pour effacer une ressource de type pizza n'a pas abouti, c'est que la pizza n'existe pas. Renvoyer juste un message d'erreur g√©n√©rique est suffisant. D'ailleurs renvoyer juste un code d'erreur est suffisant.

Pour ce tutoriel, veuillez dans votre projet GitLab cr√©er une nouvelle classe **`ResourceNotFoundException`** dans un nouveau package **`exceptions`**. Cette classe doit √©tendre la classe **`RuntimeException`** et accepter un message d'erreur en param√®tre.


```java
package be.vinci.ipl.cae.demo.exceptions;

/**
 * ResourceNotFoundException to handle resource not found exceptions.
 */
public class ResourceNotFoundException extends RuntimeException {

  /**
   * Constructor for ResourceNotFoundException.
   */
  public ResourceNotFoundException() {
    super();
  }

  /**
   * Constructor for ResourceNotFoundException.
   *
   * @param message the message.
   */
  public ResourceNotFoundException(String message) {
    super(message);
  }
}
```

Nous allons maintenant modifier notre contr√¥leur **`controllers/PizzaController`** pour utiliser cette exception personnalis√©e.

```java {12}
/**
   * Delete a pizza by id.
   *
   * @param id the pizza id.
   * @return the pizza.
   */
  @DeleteMapping("/{id}")
  @PreAuthorize("hasRole('ROLE_ADMIN')")
  public Pizza deletePizza(@PathVariable long id) {
    Pizza pizza = pizzaService.deletePizza(id);
    if (pizza == null) {
      throw new ResourceNotFoundException();
    }
    return pizza;
  }
```

Dans cet exemple, si la pizza n'est pas trouv√©e, une exception de type **`ResourceNotFoundException`** est lanc√©e. Actuellement, comme nous ne traitons pas cette exception, elle sera renvoy√©e au client sous forme de r√©ponse HTTP **`500 INTERNAL SERVER ERROR`**. Nous allons voir comment g√©rer cette exception de mani√®re centralis√©e et la logguer correctement.

## Comment g√©rer les exceptions de mani√®re centralis√©e ?

Pour g√©rer les exceptions de mani√®re centralis√©e, nous allons utiliser un gestionnaire d'exceptions global. Ce gestionnaire d'exceptions interceptera toutes les exceptions non trait√©es par les contr√¥leurs et les logguera de mani√®re appropri√©e.

Pour ce tutoriel, veuillez dans votre projet GitLab cr√©er une nouvelle classe **`GlobalExceptionHandler`** dans un nouveau package **`exceptions`**. Cette classe doit √™tre annot√©e avec **`@ControllerAdvice`** pour indiquer qu'elle est un gestionnaire d'exceptions global.

```java showLineNumbers
package be.vinci.ipl.cae.demo.exceptions;


import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.server.ResponseStatusException;

/**
 * GlobalExceptionHandler to handle exceptions globally.
 */
@ControllerAdvice
public class GlobalExceptionHandler {

  /**
   * Handle ResourceNotFoundException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(ResourceNotFoundException.class)
  public ResponseEntity<?> handleResourceNotFoundException(ResourceNotFoundException ex,
      WebRequest request) {

    if (ex.getMessage() == null) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }

    ErrorDetails errorDetails = new ErrorDetails(HttpStatus.NOT_FOUND.value(), ex.getMessage(),
        request.getDescription(false));

    return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
  }

  /**
   * Handle ResponseStatusException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(ResponseStatusException.class)
  public ResponseEntity<?> handleResponseStatusException(ResponseStatusException ex,
      WebRequest request) {

    if (ex.getReason() == null) {
      return new ResponseEntity<>(ex.getStatusCode());
    }

    ErrorDetails errorDetails = new ErrorDetails(ex.getStatusCode().value(), ex.getReason(),
        request.getDescription(false));
    return new ResponseEntity<>(errorDetails, ex.getStatusCode());
  }

  /**
   * Handle all other exceptions.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(Exception.class)
  public ResponseEntity<?> handleGlobalException(Exception ex, WebRequest request) {
    ErrorDetails errorDetails = new ErrorDetails(HttpStatus.INTERNAL_SERVER_ERROR.value(),
        ex.getMessage(), request.getDescription(false));
    return new ResponseEntity<>(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);
  }

}
```

Quelques explications sur ce code :
- La m√©thode **`handleResourceNotFoundException`** g√®re les exceptions de type **`ResourceNotFoundException`**. Elle renvoie une r√©ponse HTTP **`404 NOT FOUND`** avec le message d'erreur s'il est d√©fini.
- La m√©thode **`handleResponseStatusException`** g√®re les exceptions de type **`ResponseStatusException`**. Elle renvoie une r√©ponse HTTP avec le code de statut et le message d'erreur de l'exception. Cette m√©thode permet donc d'utiliser les exceptions de type **`ResponseStatusException`** pour renvoyer des r√©ponses HTTP aux clients, sans √™tre oblig√© de cr√©er des exceptions personnalis√©es.
- La m√©thode **`handleGlobalException`** g√®re toutes les autres exceptions non trait√©es par les contr√¥leurs. Elle renvoie une r√©ponse HTTP **`500 INTERNAL SERVER ERROR`** avec le message d'erreur de l'exception.

Afin de renvoyer dans le body de la r√©ponse HTTP un message d'erreur plus d√©taill√© au format JSON, nous allons cr√©er une classe **`ErrorDetails`** dans le m√™me package **`exceptions`**.

```java
package be.vinci.ipl.cae.demo.exceptions;

import lombok.Data;

/**
 * ErrorDetails to handle error details.
 */
@Data
public class ErrorDetails {

  private int statusCode;
  private String message;
  private String details;

  /**
   * Constructor for ErrorDetails.
   *
   * @param statusCode the status code.
   * @param message    the message.
   * @param details    the details.
   */
  public ErrorDetails(int statusCode, String message, String details) {
    this.statusCode = statusCode;
    this.message = message;
    this.details = details;
  }
}
```

Cette classe **`ErrorDetails`** contient les informations sur l'erreur √† renvoyer dans le body de la r√©ponse HTTP. Elle contient le code de statut, le message d'erreur et les d√©tails de l'erreur.

Veuillez tenter de lancer votre application Spring Boot et de tester les diff√©rentes exceptions que vous avez mises en place, avec au minimum :
- Une exception de type **`ResourceNotFoundException`** sans message d'erreur. Veuillez v√©rifier que le code de statut HTTP **`404 NOT FOUND`** est renvoy√©, et que la r√©ponse HTTP ne contient pas de body. Attention √† ne pas oublier de d'abord s'authentifier avec un utilisateur ayant le r√¥le **`ROLE_ADMIN`** pour pouvoir supprimer une pizza.
- Une exception de type **`ResourceNotFoundException`** avec un message d'erreur. Pour cela vous pouvez, dans l'op√©ration de suppression d'une pizza, utiliser **`throw new ResourceNotFoundException("Pizza not found");`**.  
Veuillez v√©rifier que le code de statut HTTP **`404 NOT FOUND`** est renvoy√©, et que la r√©ponse HTTP contient le message d'erreur dans le body.
- Une exception de type **`ResponseStatusException`**. Pour cela vous pouvez, par exemple, tentez de lire une pizza qui n'existe pas.

üí≠ Comment tester le passage dans la m√©thode globale **`handleGlobalException`** ?  Pour cela, vous pouvez par exemple, stopper votre base de donn√©es et tenter de lire une pizza. Attention, vous devez stopper la base de donn√©es apr√®s avoir bien d√©marr√© l'API ; si vous le faisiez avant, l'API ne d√©marrerait pas correctement.

Vous devriez obtenir la r√©ponse HTTP **`500 INTERNAL SERVER ERROR`** avec le message d'erreur de l'exception dans le body :

```json
{
  "statusCode": 500,
  "message": "Could not open JPA EntityManager for transaction",
  "details": "uri=/pizzas/3"
}
```

Et si l'on souhaitait conna√Ætre la classe d'exception qui a √©t√© lev√©e, comment faire ? Pour cela, il suffit de modifier la m√©thode **`handleGlobalException`** pour soit renvoyer le nom de la classe de l'exception, soit ajouter la cause de l'exception dans le message d'erreur. Ici nous avons choisi d'ajouter tant le nom de la classe que la cause de l'exception :

```java
  @ExceptionHandler(Exception.class)
  public ResponseEntity<?> handleGlobalException(Exception ex, WebRequest request) {

    ErrorDetails errorDetails = new ErrorDetails(HttpStatus.INTERNAL_SERVER_ERROR.value(),
        ex.getClass().getName() + " : " + ex.getMessage() + ". Cause: " + ex.getCause(),
        request.getDescription(false));
    return new ResponseEntity<>(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);
  }
```

Cela est impressionnant, nous sommes maintenant capable de "catcher" toutes les exceptions non trait√©es par les contr√¥leurs et de les traiter de mani√®re centralis√©e.

Pour les exceptions soulev√©es par la DB, il semble OK de les traiter au sein de la m√©thode **`handleGlobalException`** et de renvoyer un code d'erreur **`500 INTERNAL SERVER ERROR`**. Mais comment g√©rer les erreurs associ√©es √† l'autorisation ? Par exemple, si un utilisateur non autoris√© tente de supprimer une pizza alors qu'il n'est pas admin, une exception de type **`AccessDeniedException`** est lev√©e. 

# <InternalPageTitle> Comment g√©rer les exceptions de Spring Boot comme AccessDeniedException ? </InternalPageTitle>

## Introduction

Lorsqu'une exception de type **`AccessDeniedException`** est lev√©e par Spring Security, cela signifie que l'utilisateur n'est pas autoris√© √† acc√©der √† la ressource demand√©e. Cette exception est lev√©e automatiquement par Spring Security lorsqu'un utilisateur tente d'acc√©der √† une ressource sans les autorisations n√©cessaires.

Pour ce tutorial, via les requ√™tes HTTP, veuillez tenter de supprimer une pizza en tant qu'utilisateur non admin (**`guest`** par exemple). Vous devriez normalement obtenir une r√©ponse HTTP **`403 FORBIDDEN`** avec le message d'erreur **`Access is denied`**.

N√©anmoins, pour l'instant, vous recevez une r√©ponse HTTP **`500 INTERNAL SERVER ERROR`** avec le message d'erreur **` "org.springframework.security.authorization.AuthorizationDeniedException : Access Denied. Cause: null",`**. Cela signifie que l'exception de type **`AccessDeniedException`** n'est pas correctement g√©r√©e par notre gestionnaire d'exceptions global.

## Comment g√©rer les exceptions de Spring Boot ?

Ici, nous devons trouver la classe de l'exception qui est lev√©e par Spring Security lorsqu'un utilisateur n'est pas autoris√© √† acc√©der √† une ressource. 

En regardant la documentation de Spring Security (https://docs.spring.io/spring-security/reference/api/java/org/springframework/security/authorization/AuthorizationDeniedException.html), nous d√©couvrons qu'une **`AuthorizationDeniedException`** est une **`AccessDeniedException`** contenant un **`AuthorizationResult`**. Nous allons donc modifier notre gestionnaire d'exceptions global pour g√©rer les exceptions de type **`AccessDeniedException`**.

```java
  /**
   * Handle AccessDeniedException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(AccessDeniedException.class)
  public ResponseEntity<?> handleAccessDeniedException(AccessDeniedException ex,
      WebRequest request) {

    ErrorDetails errorDetails = new ErrorDetails(HttpStatus.FORBIDDEN.value(), ex.getMessage(),
        request.getDescription(false));
    return new ResponseEntity<>(errorDetails, HttpStatus.FORBIDDEN);
  }
```

Veuillez tester √† nouveau de supprimer une pizza en tant qu'utilisateur non admin (**`guest`** par exemple). Vous devriez maintenant obtenir une r√©ponse HTTP **`403 FORBIDDEN`** avec le message d'erreur :

```json
{
  "statusCode": 403,
  "message": "org.springframework.security.authorization.AuthorizationDeniedException : Access Denied. Cause: null",
  "details": "uri=/pizzas/2"
}
```

Et maintenant, veuillez tester la requ√™te pour tenter d'effacer la pizza avec l'id 2 mais sans fournir de token ! Qu'est-ce que vous obtenez ? Vous obtenez aussi un status code **`403 FORBIDDEN`** avec le message d'erreur **`Access is denied`**. Cela signifie que la m√™me exception de type **`AccessDeniedException`** est lanc√©e que l'on soit connect√© ou non. Cela est d√ª au fait que Spring Security intercepte la requ√™te avant m√™me que le contr√¥leur ne soit appel√©.  
Pour que cela soit propre, nous devrions renvoyer un code d'erreur **`401 UNAUTHORIZED`** pour indiquer que l'utilisateur n'est pas autoris√© √† acc√©der √† la ressource car il n'est pas authentifi√©. Pour cela, nous devons mettre √† jour notre code pour v√©rifier s'il y a un token dans la requ√™te et renvoyer un code d'erreur **`401 UNAUTHORIZED`** si ce n'est pas le cas.

Veuillez mettre √† jour le code de la m√©thode **`handleAccessDeniedException`** pour v√©rifier si l'utilisateur est authentifi√© et renvoyer un code d'erreur **`401 UNAUTHORIZED`** si ce n'est pas le cas.

```java {12-14} showLineNumbers
/**
   * Handle AccessDeniedException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(AccessDeniedException.class)
  public ResponseEntity<?> handleAccessDeniedException(AccessDeniedException ex,
      WebRequest request) {

    if (request.getHeader("Authorization") == null) {
      return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
    }

    ErrorDetails errorDetails = new ErrorDetails(HttpStatus.FORBIDDEN.value(),
        ex.getClass().getName() + " : " + ex.getMessage() + ". Cause: " + ex.getCause(),
        request.getDescription(false));
    return new ResponseEntity<>(errorDetails, HttpStatus.FORBIDDEN);
  }
``` 

Veuillez tester √† nouveau de supprimer une pizza en tant qu'utilisateur non authentifi√©. Vous devriez maintenant obtenir une r√©ponse HTTP **`401 UNAUTHORIZED`**. Et si vous tentez de supprimer une pizza en tant qu'utilisateur non admin, vous devriez obtenir une r√©ponse HTTP **`403 FORBIDDEN`**.

## Conclusion sur la gestion des exceptions dans une application Spring Boot

Nous avons vu comment g√©rer les exceptions de mani√®re centralis√©e dans une application Spring Boot en utilisant un gestionnaire d'exceptions global. Ce gestionnaire d'exceptions intercepte toutes les exceptions non trait√©es par les contr√¥leurs. Nous avons √©galement vu comment g√©rer les exceptions de type **`AccessDeniedException`** lev√©es par Spring Security lorsqu'un utilisateur n'est pas autoris√© √† acc√©der √† une ressource. Cet apprentissage devrait vous permettre de g√©rer n'importe quel type d'exceptions de mani√®re coh√©rente et de renvoyer des r√©ponses HTTP appropri√©es aux clients.

Nous allons maintenant voir comment logguer les exceptions de mani√®re centralis√©e pour suivre les erreurs de mani√®re coh√©rente et les corriger rapidement.

# <InternalPageTitle> Comment logguer les exceptions de mani√®re centralis√©e ? </InternalPageTitle>

## Introduction

Maintenant que nous avons appris √† centraliser les exceptions au sein d'un gestionnaire d'exceptions global, il est temps de les logguer de mani√®re centralis√©e pour suivre les erreurs de mani√®re coh√©rente et les corriger rapidement.

Pour logguer les exceptions de mani√®re centralis√©e, nous allons utiliser le logger par d√©faut de Spring Boot, **`Logback`**. **`Logback`** est une librairie de log tr√®s populaire dans l'√©cosyst√®me Spring Boot et offre de nombreuses fonctionnalit√©s pour g√©rer les logs de mani√®re efficace. C'est le successeur de **`Log4j`** et **`Log4j2`** et est largement utilis√© dans les applications Spring Boot.  

Pour information, **`Logback`** impl√©mente l'interface **`SLF4J`** (Simple Logging Facade for Java), qui est une fa√ßade de logging standardis√©e pour Java. **`SLF4J`** permet de s√©parer le code de l'application des impl√©mentations de logging, ce qui facilite le changement de librairie de log sans modifier le code de l'application.

Si vous souhaitez d√©couvrir plus en d√©tail **`Logback`**, vous pouvez consulter la documentation officielle : https://logback.qos.ch/

Par d√©faut, **`Logback`** est configur√© pour logguer les messages de niveau **`ERROR`** et sup√©rieur dans la console. 
Nous nous rendons donc compte que les exceptions de type **`AccessDeniedException`** ne sont pas loggu√©es par d√©faut, tout comme les exceptions de type **`ResponseStatusException`**, **`ResourceNotFoundException`** car elles ne sont pas affich√©es dans la console. 

Comment faire pour logguer ces exceptions de mani√®re centralis√©e ? Nous allons devoir mettre √† jour notre gestionnaire d'exceptions global pour logguer les exceptions de mani√®re appropri√©e.

## Logguer les exceptions de mani√®re centralis√©e

Veuillez mettre √† jour la classe **`exceptions/GlobalExceptionHandler`** avec ces ajouts :

```java {4-5,20,34-41,57-64,80-91,109} showLineNumbers
package be.vinci.ipl.cae.demo.exceptions;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.server.ResponseStatusException;

/**
 * GlobalExceptionHandler to handle exceptions globally.
 */
@ControllerAdvice
public class GlobalExceptionHandler {

  private Logger logger = LoggerFactory.getLogger("GlobalExceptionHandler");


  /**
   * Handle ResourceNotFoundException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(ResourceNotFoundException.class)
  public ResponseEntity<?> handleResourceNotFoundException(ResourceNotFoundException ex,
      WebRequest request) {

    ErrorDetails errorDetails = new ErrorDetails(HttpStatus.NOT_FOUND.value(), ex.getMessage(),
        request.getDescription(false));

    logger.info("Resource not found: {}", errorDetails);

    if (ex.getMessage() == null) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }

    return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
  }

  /**
   * Handle ResponseStatusException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(ResponseStatusException.class)
  public ResponseEntity<?> handleResponseStatusException(ResponseStatusException ex,
      WebRequest request) {

    ErrorDetails errorDetails = new ErrorDetails(ex.getStatusCode().value(), ex.getReason(),
        request.getDescription(false));

    logger.info("Response status exception: {}", errorDetails);

    if (ex.getReason() == null) {
      return new ResponseEntity<>(ex.getStatusCode());
    }

    return new ResponseEntity<>(errorDetails, ex.getStatusCode());
  }

  /**
   * Handle AccessDeniedException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(AccessDeniedException.class)
  public ResponseEntity<?> handleAccessDeniedException(AccessDeniedException ex,
      WebRequest request) {

    if (request.getHeader("Authorization") == null) {
      ErrorDetails errorDetails = new ErrorDetails(HttpStatus.UNAUTHORIZED.value(),
          ex.getClass().getName() + " : " + ex.getMessage() + ". Cause: " + ex.getCause(),
          request.getDescription(false));
      logger.info("Unauthorized access: {}", errorDetails);
      return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
    }

    ErrorDetails errorDetails = new ErrorDetails(HttpStatus.FORBIDDEN.value(),
        ex.getClass().getName() + " : " + ex.getMessage() + ". Cause: " + ex.getCause(),
        request.getDescription(false));
    logger.info("Forbidden access: {}", errorDetails);
    return new ResponseEntity<>(errorDetails, HttpStatus.FORBIDDEN);
  }

  /**
   * Handle all other exceptions.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(Exception.class)
  public ResponseEntity<?> handleGlobalException(Exception ex, WebRequest request) {

    ErrorDetails errorDetails = new ErrorDetails(HttpStatus.INTERNAL_SERVER_ERROR.value(),
        ex.getClass().getName() + " : " + ex.getMessage() + ". Cause: " + ex.getCause(),
        request.getDescription(false));

    logger.error("Internal server error: {}", errorDetails);

    return new ResponseEntity<>(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);
  }
}
```

Quelques explications sur ce code :
- Nous avons ajout√© un logger de type **`Logger`** pour logguer les exceptions de mani√®re centralis√©e. Nous lui avons donn√© le nom **`GlobalExceptionHandler`** pour le distinguer des √©ventuels autres loggers.
- Nous avons ajout√© des instructions **`logger.info`** et **`logger.error`** pour logguer les exceptions de mani√®re appropri√©e. Nous utilisons le niveau **`INFO`** pour les exceptions de type **`ResourceNotFoundException`**, **`ResponseStatusException`** et **`AccessDeniedException`**, et le niveau **`ERROR`** pour les autres exceptions non trait√©es par les contr√¥leurs.
- Nous avons ajout√© des messages d'erreur d√©taill√©s pour chaque type d'exception, y compris le code de statut, le message d'erreur et les d√©tails de l'erreur. Ces messages d'erreur seront loggu√©s dans la console et permettront de suivre les erreurs de mani√®re coh√©rente.

Pour rappel, voici les diff√©rents niveau de log que l'on peut utiliser avec **`Logback`** :
- **`TRACE`** : Informations d√©taill√©es sur le fonctionnement de l'application, utiles pour le d√©bogage.
- **`DEBUG`** : Informations de d√©bogage, utiles pour comprendre le fonctionnement interne de l'application.
- **`INFO`** : Informations g√©n√©rales sur le fonctionnement de l'application.
- **`WARN`** : Avertissements sur des situations potentiellement probl√©matiques.
- **`ERROR`** : Erreurs qui ont emp√™ch√© le bon fonctionnement de l'application.

Pour cr√©er un log selon le niveau ad√©quat, il suffit d'appeler la m√©thode correspondante sur l'objet **`Logger`**. Par exemple, pour cr√©er un log de niveau **`INFO`**, on appelle la m√©thode **`logger.info`**.

Quelle est la diff√©rence entre un niveau **`Trace`** et un niveau **`Debug`** ? Le niveau **`Trace`** est plus d√©taill√© que le niveau **`Debug`**. Le niveau **`Trace`** est utilis√© pour des informations tr√®s d√©taill√©es sur le fonctionnement de l'application, utiles pour le d√©bogage. Le niveau **`Debug`** est utilis√© pour des informations de d√©bogage, utiles pour comprendre le fonctionnement interne de l'application.

Veuillez tester √† nouveau de supprimer une pizza en tant qu'utilisateur non authentifi√©. Vous devriez maintenant obtenir une r√©ponse HTTP **`401 UNAUTHORIZED`** et voir le message d'erreur loggu√© dans la console.  

Vous remarquez que dans le d√©tails, on ne voit pas beaucoup d'informations. On souhaiterait par exemple conna√Ætre le type de requ√™te faire sur l'URI.

Pour ce faire, voici comment on pourrait modifier la classe **`GlobalExceptionHandler`** pour ajouter le type de requ√™te et d'autres infos sur le client ayant fait la requ√™te amenant √† une exception :

```java showLineNumbers
package be.vinci.ipl.cae.demo.exceptions;


import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.server.ResponseStatusException;

/**
 * GlobalExceptionHandler to handle exceptions globally.
 */
@ControllerAdvice
public class GlobalExceptionHandler {

  private Logger logger = LoggerFactory.getLogger("GlobalExceptionHandler");


  /**
   * Handle ResourceNotFoundException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(ResourceNotFoundException.class)
  public ResponseEntity<?> handleResourceNotFoundException(ResourceNotFoundException ex,
      WebRequest request, HttpServletRequest httpRequest) {

    ErrorDetails errorDetailsClient = new ErrorDetails(HttpStatus.NOT_FOUND.value(),
        ex.getMessage(),
        request.getDescription(false));

    ErrorDetails errorDetailsLog = new ErrorDetails(HttpStatus.NOT_FOUND.value(), ex.getMessage(),
        "httpMethod=" + httpRequest.getMethod() + ";" + request.getDescription(true));

    logger.info("Resource not found: {}", errorDetailsLog);

    if (ex.getMessage() == null) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }

    return new ResponseEntity<>(errorDetailsClient, HttpStatus.NOT_FOUND);
  }

  /**
   * Handle ResponseStatusException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(ResponseStatusException.class)
  public ResponseEntity<?> handleResponseStatusException(ResponseStatusException ex,
      WebRequest request, HttpServletRequest httpRequest) {

    ErrorDetails errorDetailsClient = new ErrorDetails(ex.getStatusCode().value(), ex.getReason(),
        request.getDescription(false));
    ErrorDetails errorDetailsLog = new ErrorDetails(ex.getStatusCode().value(), ex.getReason(),
        "httpMethod=" + httpRequest.getMethod() + ";" + request.getDescription(true));

    logger.info("Response status exception: {}", errorDetailsLog);

    if (ex.getReason() == null) {
      return new ResponseEntity<>(ex.getStatusCode());
    }

    return new ResponseEntity<>(errorDetailsClient, ex.getStatusCode());
  }

  /**
   * Handle AccessDeniedException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(AccessDeniedException.class)
  public ResponseEntity<?> handleAccessDeniedException(AccessDeniedException ex,
      WebRequest request, HttpServletRequest httpRequest) {

    if (request.getHeader("Authorization") == null) {
      ErrorDetails errorDetails = new ErrorDetails(HttpStatus.UNAUTHORIZED.value(),
          ex.getClass().getName() + " : " + ex.getMessage() + ". Cause: " + ex.getCause(),
          "httpMethod=" + httpRequest.getMethod() + ";" + request.getDescription(true));

      logger.info("Unauthorized access: {}", errorDetails);
      return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
    }

    ErrorDetails errorDetailsClient = new ErrorDetails(HttpStatus.FORBIDDEN.value(),
        ex.getClass().getName() + " : " + ex.getMessage() + ". Cause: " + ex.getCause(),
        request.getDescription(false));

    ErrorDetails errorDetailsLog = new ErrorDetails(HttpStatus.FORBIDDEN.value(),
        ex.getClass().getName() + " : " + ex.getMessage() + ". Cause: " + ex.getCause(),
        "httpMethod=" + httpRequest.getMethod() + ";" + request.getDescription(true));

    logger.info("Forbidden access: {}", errorDetailsLog);
    return new ResponseEntity<>(errorDetailsClient, HttpStatus.FORBIDDEN);
  }

  /**
   * Handle all other exceptions.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(Exception.class)
  public ResponseEntity<?> handleGlobalException(Exception ex, WebRequest request,
      HttpServletRequest httpRequest) {

    ErrorDetails errorDetailsClient = new ErrorDetails(HttpStatus.INTERNAL_SERVER_ERROR.value(),
        ex.getClass().getName() + " : " + ex.getMessage() + ". Cause: " + ex.getCause(),
        request.getDescription(false));

    ErrorDetails errorDetailsLog = new ErrorDetails(HttpStatus.INTERNAL_SERVER_ERROR.value(),
        ex.getClass().getName() + " : " + ex.getMessage() + ". Cause: " + ex.getCause(),
        "httpMethod:" + httpRequest.getMethod() + request.getDescription(true));

    logger.error("Internal server error: {}", errorDetailsLog);

    return new ResponseEntity<>(errorDetailsClient, HttpStatus.INTERNAL_SERVER_ERROR);
  }
}
``` 

Est-ce que ce code est correct point de vue de PMD & CPD ?  
N'h√©sitez pas √† lancer les outils de v√©rification de code pour le v√©rifier, comme par exemple localement via :

```bash
mvn clean test
```

Une fois cette commande lanc√©e, on voit qu'il y a de la duplication de code. Comment pourrait-on am√©liorer cela ?

Pour √©viter la duplication de code, on pourrait extraire la logique de cr√©ation des **`ErrorDetails`** dans une m√©thode priv√©e. Voici comment mettre √† jour la classe **`GlobalExceptionHandler`** pour extraire la logique de cr√©ation des **`ErrorDetails`** dans une m√©thode priv√©e :

```java showLineNumbers
package be.vinci.ipl.cae.demo.exceptions;

import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.server.ResponseStatusException;

/**
 * GlobalExceptionHandler to handle exceptions globally.
 */
@ControllerAdvice
public class GlobalExceptionHandler {

  private Logger logger = LoggerFactory.getLogger("GlobalExceptionHandler");

  private ErrorDetails createErrorDetails(HttpStatus status, Exception ex, WebRequest request,
      HttpServletRequest httpRequest, boolean forLog) {
    String description =
        forLog ? "httpMethod=" + httpRequest.getMethod() + ";" + request.getDescription(true)
            : request.getDescription(false);
    return new ErrorDetails(status.value(),
        ex.getClass().getName() + " : " + ex.getMessage() + ". Cause: " + ex.getCause(),
        description);
  }

  /**
   * Handle ResourceNotFoundException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(ResourceNotFoundException.class)
  public ResponseEntity<?> handleResourceNotFoundException(ResourceNotFoundException ex,
      WebRequest request, HttpServletRequest httpRequest) {
    ErrorDetails errorDetailsClient = createErrorDetails(HttpStatus.NOT_FOUND, ex, request,
        httpRequest, false);
    ErrorDetails errorDetailsLog = createErrorDetails(HttpStatus.NOT_FOUND, ex, request,
        httpRequest, true);

    logger.info("Resource not found: {}", errorDetailsLog);

    if (ex.getMessage() == null) {
      return new ResponseEntity<>(HttpStatus.NOT_FOUND);
    }

    return new ResponseEntity<>(errorDetailsClient, HttpStatus.NOT_FOUND);
  }

  /**
   * Handle ResponseStatusException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(ResponseStatusException.class)
  public ResponseEntity<?> handleResponseStatusException(ResponseStatusException ex,
      WebRequest request, HttpServletRequest httpRequest) {
    ErrorDetails errorDetailsClient = createErrorDetails(
        HttpStatus.valueOf(ex.getStatusCode().value()), ex, request,
        httpRequest, false);
    ErrorDetails errorDetailsLog = createErrorDetails(
        HttpStatus.valueOf(ex.getStatusCode().value()), ex, request, httpRequest,
        true);

    logger.info("Response status exception: {}", errorDetailsLog);

    if (ex.getReason() == null) {
      return new ResponseEntity<>(ex.getStatusCode());
    }

    return new ResponseEntity<>(errorDetailsClient, ex.getStatusCode());
  }

  /**
   * Handle AccessDeniedException.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(AccessDeniedException.class)
  public ResponseEntity<?> handleAccessDeniedException(AccessDeniedException ex, WebRequest request,
      HttpServletRequest httpRequest) {
    if (request.getHeader("Authorization") == null) {
      ErrorDetails errorDetails = createErrorDetails(HttpStatus.UNAUTHORIZED, ex, request,
          httpRequest, true);
      logger.info("Unauthorized access: {}", errorDetails);
      return new ResponseEntity<>(HttpStatus.UNAUTHORIZED);
    }

    ErrorDetails errorDetailsClient = createErrorDetails(HttpStatus.FORBIDDEN, ex, request,
        httpRequest, false);
    ErrorDetails errorDetailsLog = createErrorDetails(HttpStatus.FORBIDDEN, ex, request,
        httpRequest, true);

    logger.info("Forbidden access: {}", errorDetailsLog);
    return new ResponseEntity<>(errorDetailsClient, HttpStatus.FORBIDDEN);
  }

  /**
   * Handle all other exceptions.
   *
   * @param ex      the exception.
   * @param request the request.
   * @return the response entity.
   */
  @ExceptionHandler(Exception.class)
  public ResponseEntity<?> handleGlobalException(Exception ex, WebRequest request,
      HttpServletRequest httpRequest) {
    ErrorDetails errorDetailsClient = createErrorDetails(HttpStatus.INTERNAL_SERVER_ERROR, ex,
        request, httpRequest, false);
    ErrorDetails errorDetailsLog = createErrorDetails(HttpStatus.INTERNAL_SERVER_ERROR, ex, request,
        httpRequest, true);

    logger.error("Internal server error: {}", errorDetailsLog);

    return new ResponseEntity<>(errorDetailsClient, HttpStatus.INTERNAL_SERVER_ERROR);
  }
}
```

Est-ce que ce code est correct point de vue de PMD & CPD ?  
N'h√©sitez pas √† lancer les outils de v√©rification de code pour le v√©rifier, comme par exemple localement via :

```bash
mvn clean test
```

Maintenant, nous avons une m√©thode priv√©e **`createErrorDetails`** qui prend en param√®tre le code de statut, l'exception, la requ√™te, la requ√™te HTTP et un bool√©en pour indiquer si les d√©tails sont pour le log ou pour le client. Cette m√©thode cr√©e un objet **`ErrorDetails`** avec les informations n√©cessaires pour logguer l'erreur de mani√®re centralis√©e.

Veuillez tester √† nouveau de supprimer une pizza en tant qu'utilisateur non authentifi√©. Vous devriez maintenant obtenir une r√©ponse HTTP **`401 UNAUTHORIZED`** et voir le message d'erreur loggu√© dans la console avec le type de requ√™te et d'autres informations sur le client ayant fait la requ√™te.  
Veuillez aussi observer que le message d'erreur renvoy√© au client ne contient pas d'informations sensibles !

## Configuration de Logback

### Introduction

Nous souhaitons toujours afficher les logs de niveau **`ERROR`** et sup√©rieur dans la console, tout en logguant toutes les exceptions de type **`AccessDeniedException`**, **`ResponseStatusException`**, **`ResourceNotFoundException`**, etc..., dans un fichier de log.

Dans les profiles de d√©veloppement, nous souhaitons afficher les logs de niveau **`DEBUG`** et sup√©rieur dans la console, tout en logguant toutes les exceptions dans un fichier de log.

Dans les profiles de production, nous souhaitons afficher les logs de niveau **`INFO`** et sup√©rieur dans la console, tout en logguant toutes les exceptions dans un fichier de log.
Pourquoi ? Parce que les logs de niveau **`DEBUG`** peuvent contenir des informations sensibles sur le fonctionnement interne de l'application et ne doivent pas √™tre activ√©s en production.

### Configuration de Logback pour le profile de d√©veloppement

Nous pouvons configurer certaines options dans le fichier **`application.properties`** pour √©crire les logs dans le fichier **`logs/application.log`**. Pour cela, veuillez ajouter les lignes suivantes dans le fichier **`application.properties`** :

```properties
debug=true
logging.file.name=logs/application.log
logging.logback.rollingpolicy.max-file-size=10MB
logging.logback.rollingpolicy.max-history=7
``` 

Ces lignes permettent de configurer le fichier de log **`logs/application.log`** pour qu'il ne d√©passe pas 10 Mo et qu'il conserve les 7 derniers fichiers de log.

**`debug=true`** permet d'activer les logs de niveau **`DEBUG`** et sup√©rieur dans la console.


Comme nous ne pr√©cisons pas le niveau de log, toutes les exceptions seront loggu√©es dans ce fichier de log.

Est-ce que les logs sont aussi affich√©s dans la console ? Oui, les logs sont √©galement affich√©s dans la console, car nous n'avons pas modifi√© la configuration par d√©faut de **`Logback`** pour afficher les logs dans la console.  
Si on avait souhait√© stopper l'affichage des logs dans la console, on pourrait ajouter la ligne suivante dans le fichier **`application.properties`** :

```properties
logging.pattern.console=
```

Cela aurait permis de supprimer les logs de la console, mais nous ne souhaitons pas le faire !

### Ignorer les fichiers de log dans Git

Pour √©viter de commiter les fichiers de log dans Git, nous devons ajouter le dossier **`logs`** dans le fichier **`.gitignore`**. Pour cela, veuillez ajouter la ligne suivante dans le fichier **`.gitignore`** de votre API :

```properties
logs/
```

Veuillez red√©marrer votre API et tester √† nouveau de supprimer une pizza en tant qu'utilisateur non authentifi√©. Vous devriez maintenant obtenir une r√©ponse HTTP **`401 UNAUTHORIZED`** et voir le message d'erreur loggu√© dans le fichier **`logs/application.log`**. De plus, vous devriez voir les logs de niveau **`DEBUG`** et sup√©rieur dans la console.

### Configuration de Logback pour le profile de d√©veloppement pour plus de d√©tails sur les logs de type DB

Pour avoir plus de d√©tails sur les logs de type DB, nous pouvons ajouter les lignes suivantes dans le fichier **`application.properties`** :

```properties
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

Que font ces lignes ?

- **`spring.jpa.show-sql=true`** permet d'afficher les requ√™tes SQL g√©n√©r√©es par Hibernate dans la console.
- **`spring.jpa.properties.hibernate.format_sql=true`** permet de formater les requ√™tes SQL g√©n√©r√©es par Hibernate pour les rendre plus lisibles.
- **`logging.level.org.hibernate.SQL=DEBUG`** permet d'afficher les requ√™tes SQL g√©n√©r√©es par Hibernate dans la console avec le niveau de log **`DEBUG`**.
- **`logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE`** permet d'afficher les valeurs des param√®tres des requ√™tes SQL g√©n√©r√©es par Hibernate dans la console avec le niveau de log **`TRACE`**.


### Configuration de Logback pour le profile de production

Est-ce que les logs de type **`DEBUG`** sont activ√©s en production ? Non, les logs de type **`DEBUG`** ne sont pas activ√©s en production, car ils peuvent contenir des informations sensibles sur le fonctionnement interne de l'application. Nous allons donc configurer **`Logback`** pour afficher les logs de niveau **`INFO`** et sup√©rieur en production.

Dans le fichier **`application-production.properties`**, veuillez ajouter les
lignes suivantes :

```properties
logging.level.root=INFO
logging.file.name=logs/application.log
logging.logback.rollingpolicy.max-file-size=10MB
logging.logback.rollingpolicy.max-history=7
```

Ces lignes permettent de configurer le niveau de log √† **`INFO`** et sup√©rieur en production, et d'√©crire les logs dans le fichier **`logs/application.log`**.

### Configuration de Logback pour le profile de test et le profile de staging

Pour les profiles de test et de staging, nous souhaitons afficher les logs de niveau **`DEBUG`** et sup√©rieur dans la console, tout en logguant toutes les exceptions dans un fichier de log.

Dans le fichier **`application-test.properties`**, veuillez ajouter les lignes suivantes :

```properties
logging.level.root=DEBUG
logging.file.name=logs/application.log
logging.logback.rollingpolicy.max-file-size=10MB
logging.logback.rollingpolicy.max-history=7

spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

Dans le fichier **`application-staging.properties`**, veuillez ajouter les lignes suivantes :

```properties
logging.level.root=DEBUG
logging.file.name=logs/application.log
logging.logback.rollingpolicy.max-file-size=10MB
logging.logback.rollingpolicy.max-history=7
```

# <InternalPageTitle> Comment visualiser les logs dans l'environnement d√©ploy√© ? </InternalPageTitle>

## Introduction

Comment visualiser les logs dans l'environnement d√©ploy√© ?  
Ou en d'autres termes, comment stocker les logs dans un endroit s√ªr et les consulter facilement pour suivre les erreurs de mani√®re coh√©rente et les corriger rapidement ?

Dans notre cours, nous avons choisi de d√©ployer l'API dans Azure Web App √† l'aide de Docker Compose. De plus, pour les assets, nous utilisons Azure Blob Storage. Nous allons donc tenter de stocker les logs dans Azure Blob Storage pour les rendre persistants et les consulter (facilement).

## Visualiser les derniers logs dans le portail Azure

Dans le portail Azure, vous pouvez visualiser les derniers logs de l'API en temps r√©el. Pour cela, veuillez suivre ces √©tapes :
- Connectez-vous au portail Azure.
- Recherchez et s√©lectionnez votre **`App Service`**.
- Dans le menu de gauche, s√©lectionnez **`Log stream`**.
- Vous pouvez maintenant voir les logs en temps r√©el de l'API.

## Stocker les diagnostics dans Azure storage

### Cr√©ation d'un compte de stockage Azure

Pour stocker les logs dans Azure Blob Storage, vous devez cr√©er un compte de stockage Azure dans la m√™me r√©gion que votre Azure Web App. 

Nous vous avons jusque l√† recommand√© de cr√©er vos services Azure dans la r√©gion **`Central US`**. Pourquoi ? C'est aussi la r√©gion la moins ch√®re pour les √©tudiants Azure.

Pour que le service de stockage soit visible par l'Azure Web App, il doit √™tre dans la m√™me r√©gion que l'Azure Web App.

Vous pourriez utiliser le service de stockage cr√©√© pour stocker les images de l'API pour stocker les logs de l'API. 

N√©anmoins, pour √™tre s√ªr que le service de stockage est dans la m√™me r√©gion que l'Azure Web App, nous allons cr√©er un nouveau service de stockage pour stocker les logs de l'API. 

Veuillez v√©rifier la r√©gion de votre Azure Web App dans le portail Azure et cr√©er un compte de stockage Azure dans la m√™me r√©gion. Pour cela, veuillez suivre ces √©tapes :
- Connectez-vous au portail Azure.
- Choisissez **`Free services`** dans la recherche pour voir les services gratuits.
- Recherchez et s√©lectionnez **`Azure Blob Storage`**.
- Indiquez comme **`Resource group`** le m√™me que celui de votre Azure Web App.
- Donnez un nom √† votre compte de stockage, par exemple **`log007`**.
- Cliquez sur **`Review + create`**.
- Cliquez sur **`Create`**.
- Cliquez sur **`Go to resource`** une fois le compte de stockage cr√©√©.


### Stockage des logs dans un Azure Blob Storage

Veuillez activer les diagnostics de l'API dans Azure Web App. Pour cela, veuillez suivre ces √©tapes :
- Connectez-vous au portail Azure.
- Recherchez et s√©lectionnez votre **`App Service`**.
- Dans le menu de gauche, s√©lectionnez **`Diagnostics settings`**.
- Cliquez sur **`Add diagnostic setting`**.
- Donnez un nom √† votre diagnostic setting, par exemple **`Project diagnostic`**.
- S√©lectionnez les logs que vous souhaitez stocker. Pour ce tutoriel, nous allons s√©lectionner **`App Service Console Logs`**, **`App Service Application Logs`** et **`App Service Platform logs`**.
- S√©lectionnez le **`Destination`**. Pour ce tutoriel, nous allons s√©lectionner **`Archive to a storage account`**.
- Pour la **`Subscription`**, s√©lectionnez votre abonnement Azure, **`Azure for Students`** par exemple.
- Pour le **`Storage account`**, s√©lectionnez un compte de stockage Azure existant, celui que vous avez cr√©√© dans la m√™me r√©gion et dans le m√™me Resource group (**`log007`** par exemple).
- Cliquez sur **`Save`**.

### Activation des logs dans Azure Web App

Comme nous capturons les Application Logs, nous devons activer les logs dans Azure Web App. Pour cela, veuillez suivre ces √©tapes :
- Connectez-vous au portail Azure.
- Recherchez et s√©lectionnez votre **`App Service`**.
- Dans le menu de gauche, Dans **`Monitoring`**, s√©lectionnez **`App Service logs`**.
- Pour **`Application Logging`**, s√©lectionnez **`File System`**.
- Cliquez sur **`Save`**.
`**.

## Acc√®s aux logs

### Acc√®s aux outils avanc√©s et au t√©l√©chargement des logs

Comment acc√©der aux logs cr√©√©s ? Pour acc√©der √† ces logs, vous pouvez soit utiliser les **`Advanced Tools`** de l'Azure Web App. Pour cela, veuillez suivre ces √©tapes :
- Connectez-vous au portail Azure.
- Recherchez et s√©lectionnez votre **`App Service`**.
- Dans le menu de gauche, dans **`Development Tools`**, s√©lectionnez **`Advanced tools`** et cliquez sur **`Go`**.
- Cliquez sur **`Current Docker logs`** (**`Download as zip`**) pour t√©l√©charger les logs de Docker.
- NB : Il est aussi possible de cliquer sur **`Log stream`** pour visualiser les logs en temps r√©el, mais √ßa semble moins bien fonctionner que le **`Log stream`** de l'Azure Web App que nous avons d√©j√† vu.

### Acc√®s aux logs dans Azure Blob Storage

Les logs de Azure Web App sont disponibles dans votre compte de stockage Azure. Pour les visualiser, veuillez suivre ces √©tapes :
- Connectez-vous au portail Azure.
- Recherchez et s√©lectionnez votre **`Storage account`**.
- Dans le menu de gauche, s√©lectionnez **`Containers`**.
- Vous pouvez maintenant voir les logs de l'API dans le conteneur **`insights-logs-appserviceconsolelogs`** et **`insights-logs-appserviceplatformlogs`**.

Ces logs sont stock√©s dans des fichiers de log au format **`json`**. Vous pourriez les t√©l√©charger et les consulter facilement pour suivre les erreurs de mani√®re coh√©rente et les corriger rapidement.

N√©anmoins, il serait plus facile d'avoir une application qui permette de visualiser les logs en temps r√©el. Pour cela, vous pourriez utiliser Azure Monitor pour visualiser les logs en temps r√©el.

# <InternalPageTitle> Utiliser Azure Monitor pour visualiser les logs en temps r√©el </InternalPageTitle>


## Introduction

Azure Monitor est un service Azure qui permet de visualiser et faire des requ√™tes sur les logs quasi en temps r√©el, √† quelques minutes pr√®s. Pour l'utiliser, vous devez cr√©er un **`Log Analytics workspace`** et connecter votre Azure Web App √† ce workspace.

## Cr√©ation d'un Log Analytics workspace

Pour cr√©er un **`Log Analytics workspace`**, veuillez suivre ces √©tapes :
- Connectez-vous au portail Azure.
- Recherchez et s√©lectionnez **`Log Analytics workspaces`**.
- Cliquez sur **`Create`**.
- S√©lectionnez votre abonnement Azure, **`Azure for Students`** par exemple.
- S√©lectionnez le **`Resource group`** de votre Azure Web App, **`pizzeria_group`** par exemple.
- Donnez un nom √† votre workspace, par exemple **`cae-log-analytics`**.
- S√©lectionnez la r√©gion de votre Azure Web App, **`Central US`** par exemple.
- Cliquez sur **`Review + create`**.
- Cliquez sur **`Create`**.
- Cliquez sur **`Go to resource`** une fois le workspace cr√©√©.

## Connecter votre Azure Web App √† votre Log Analytics workspace

Pour connecter votre Azure Web App √† votre **`Log Analytics workspace`**, veuillez suivre ces √©tapes :
- Connectez-vous au portail Azure.
- Recherchez et s√©lectionnez votre **`App Service`**.
- Dans le menu de gauche, s√©lectionnez **`Diagnostics settings`**.
- Cliquez sur **`Add diagnostic setting`**.
- Donnez un nom √† votre diagnostic setting, par exemple **`Project analytics`**.
- S√©lectionnez les logs que vous souhaitez stocker. Pour ce tutoriel, nous allons s√©lectionner **`App Service Console Logs`**, **`App Service Application Logs`** et **`App Service Platform logs`**.
- S√©lectionnez le **`Destination`**. Pour ce tutoriel, nous allons maintenant s√©lectionner **`Send to Log Analytics`**.
- Pour la **`Subscription`**, s√©lectionnez votre abonnement Azure, **`Azure for Students`** par exemple.
- Pour le **`Log Analytics workspace`**, s√©lectionnez le workspace que vous avez cr√©√©, **`cae-log-analytics`** par exemple.
- Cliquez sur **`Save`**.

## Visualiser les logs en temps r√©el dans Azure Monitor

Il est maintenant possible de faire des requ√™tes sur les logs de l'API dans Azure Monitor ou directement dans le **`Monitoring`** de l'Azure Web App.

Pour cela, veuillez suivre ces √©tapes :
- Connectez-vous au portail Azure.
- S√©lectionnez votre **`Azure Web App`**.
- Dans le menu de gauche, s√©lectionnez **`Monitoring`**.
- S√©lectionnez **`Logs`**.
- Vous pouvez maintenant faire des requ√™tes sur les logs de l'API en temps r√©el.
- Un Queries hub est disponible pour vous aider √† √©crire des requ√™tes sur les logs de l'API. Pour ce tutoriel, vous pouvez le fermer.
- Cliquez sur **`Table`**, et dans **`App Services`**, s√©lectionnez **`AppServiceConsoleLogs`**.
- Vous pouvez maintenant voir les logs de l'API en temps r√©el.
- En cliquant sur **`Simple mode`**, vous pouvez switcher vers le mode **`KQL mode`** pour √©crire des requ√™tes plus avanc√©es sur les logs de l'API.
- En tapant sur **Enter** apr√®s **AppServiceConsoleLogs**, vous devriez obtenir des options pour construire votre requ√™te. Par exemple, vous pouvez remplacer la requ√™te par **`AppServiceConsoleLogs | where ResultDescription contains "ERROR"`** pour afficher les logs d'erreur de l'API.

Attention, il est possible que les logs ne soient pas imm√©diatement disponibles dans Azure Monitor. Il faut parfois attendre quelques minutes avant qu'ils deviennent disponibles.

## Conclusion sur la visualisation des logs dans l'environnement d√©ploy√©

Dans ce tutoriel, nous avons vu comment visualiser les logs dans l'environnement d√©ploy√©. La fa√ßon la plus simple et directe est d'utiliser le stream de logs de l'Azure Web App. Cela permet de visualiser les logs en temps r√©el, mais ne permet pas de faire des requ√™tes sur les logs.

Nous avons vu comment stocker les logs dans Azure Blob Storage pour les rendre persistants et les consulter. Nous nous sommes rendus compte que les logs sauvegard√©s dans Azure Blob Storage sont stock√©s dans des fichiers de log au format **`json`** qui ne sont pas facilement lisibles pour les humains. Ces fichiers n√©cessitent un traitement suppl√©mentaire pour √™tre lus et compris, notamment par des outils de visualisation de logs comme Azure Monitor (ou d'autres outils de visualisation de logs comme Grafana, Kibana, etc...).

Nous avons aussi vu comment utiliser **Azure Monitor** pour faire des requ√™tes sur les logs quasi en temps r√©el, √† quelques minutes pr√®s.

Nous devrions √† pr√©sent comprendre que la gestion des logs d√©pend fortement de chaque provider cloud. 

N'h√©sitez pas √† consulter la documentation de votre provider cloud pour plus d'informations sur la gestion des logs.

Une autre fa√ßon int√©ressante de g√©rer la persistance des logs pourrait √™tre d'utiliser Spring pour directement stocker les logs dans Azure Blob Storage. Cela pourrait √™tre une piste int√©ressante pour vos projets.  
N'h√©sitez pas √† explorer cette piste pour vos projets.

Si n√©cessaire, vous pouvez trouver le code associ√© √† la gestion des erreurs et des logs ici : [logs](https://github.com/e-vinci/cae-theory-demos/tree/main/logs).
