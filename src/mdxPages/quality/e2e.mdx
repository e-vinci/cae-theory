---
title: Tests e2e
description: Tests e2e
date: 23/01/2025
---

<InternalPageMenu>
  <PathViewer>
    <PathViewerItem to="/"> CAE </PathViewerItem>
    <PathViewerItem to="/quality"> Qualit√© </PathViewerItem>
    <PathViewerItem selected> Tests e2e </PathViewerItem>
  </PathViewer>
  <InternalPageMenuItem> Comment g√©rer des tests de bout en bout ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment mettre en place les tests e2e avec Playwright ? </InternalPageMenuItem>
  <InternalPageMenuItem> O√π enregistrer les sp√©cifications de test ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment tester une application web avec Playwright ?  </InternalPageMenuItem>
  <InternalPageMenuItem> Comment s'assurer de l'√©tat de l'application avant de commencer les tests ?  </InternalPageMenuItem>
  <InternalPageMenuItem> Comment g√©rer les duplications de code dans les tests ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment √©crire des tests e2e de qualit√© ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment int√©grer les tests e2e dans le pipeline de CI ? </InternalPageMenuItem>
  <InternalPageMenuItem> Comment utiliser le cache de GitLab CI ? </InternalPageMenuItem>
</InternalPageMenu>



# <InternalPageTitle> Comment g√©rer des tests de bout en bout ? </InternalPageTitle>

## Introduction

Les tests de bout en bout (e2e) sont des tests qui simulent le comportement d'un utilisateur sur une application. Ils permettent de v√©rifier que l'application fonctionne correctement dans son ensemble, en testant l'interaction entre les diff√©rentes parties de l'application.

Pour pouvoir g√©rer efficacement les tests e2e, il est important de suivre quelques bonnes pratiques :
- **D√©finir une strat√©gie de test** : Avant de commencer √† √©crire des tests e2e, il est important de d√©finir une strat√©gie de test qui d√©termine quels sc√©narios seront test√©s et comment ils seront test√©s.
- **Utiliser des outils adapt√©s** : Il existe de nombreux outils pour √©crire des tests e2e, comme Playwright, Cypress, Selenium ou Puppeteer. Il est important de choisir l'outil qui convient le mieux √† votre projet.
- **√âcrire des tests robustes** : Les tests e2e doivent √™tre robustes et fiables. Il est important de s'assurer qu'ils sont capables de d√©tecter les erreurs et les probl√®mes potentiels dans l'application.
- **Automatiser les tests** : Les tests e2e doivent √™tre automatis√©s pour pouvoir √™tre ex√©cut√©s r√©guli√®rement et rapidement. Il est important de les int√©grer dans votre pipeline CI/CD.
- **Suivre les bonnes pratiques de d√©veloppement** : Comme pour les autres types de tests, il est important de suivre les bonnes pratiques de d√©veloppement pour √©crire des tests e2e de qualit√©.

Pour ce cours, nous avons choisi l'outil **Playwright** pour √©crire nos tests e2e. Playwright est un outil moderne et puissant qui permet d'√©crire des tests e2e pour les applications web et mobiles. Il offre de nombreuses fonctionnalit√©s avanc√©es, comme la prise en charge des applications PWA, des tests parall√®les et la possibilit√© de tester sur plusieurs navigateurs.

## Comment d√©finir une strat√©gie de test e2e ?

### Introduction 

Avant de commencer √† √©crire des tests e2e, il est important de d√©finir une strat√©gie de test qui d√©termine quels sc√©narios seront test√©s et comment ils seront test√©s. Voici quelques √©tapes √† suivre pour d√©finir une strat√©gie de test e2e :
- **Identifier les sc√©narios √† tester** : Commencez par identifier les sc√©narios les plus importants de votre application. Il peut s'agir de sc√©narios critiques pour le bon fonctionnement de l'application, de sc√©narios qui couvrent les fonctionnalit√©s les plus utilis√©es par les utilisateurs, ou de sc√©narios qui ont √©t√© √† l'origine de bugs dans le pass√©.
- **D√©terminer les cas de test** : Pour chaque sc√©nario identifi√©, d√©terminez les cas de test ("test cases" en anglais) √† ex√©cuter. Un cas de test est une s√©quence d'actions qui permet de v√©rifier le bon fonctionnement d'une fonctionnalit√© de l'application.

### Identification des sc√©narios √† tester

Un sc√©nario de test d√©crit une situation ou un flux d'utilisation sp√©cifique que vous souhaitez tester. Il se concentre sur les actions de l'utilisateur et les r√©sultats attendus de mani√®re g√©n√©rale.

Pour identifier les sc√©narios √† tester, nous vous recommandons cette approche :
- **Identification des cas d'utilisation** : Commencez par identifier les cas d'utilisation de votre application. Un cas d'utilisation est une description d'une interaction entre un utilisateur et l'application, c'est une fonctionnalit√© offerte par votre application.
- **Priorisation des cas d'utilisation** : Priorisez les cas d'utilisation en fonction de leur importance pour l'application. Vous pouvez utiliser des crit√®res comme la criticit√©, la fr√©quence d'utilisation, ou l'impact sur l'exp√©rience utilisateur.
- **D√©finition des sc√©narios de test** : Pour chaque cas d'utilisation prioris√©, d√©finissez un ou plusieurs sc√©narios de test qui couvrent les diff√©rentes √©tapes de l'interaction entre l'utilisateur et l'application.

Par exemple, pour tester le cas d'utilisation "Cr√©er un compte utilisateur", vous pourriez d√©finir les sc√©narios de test suivants :
- **Sc√©nario 1** : L'utilisateur saisit son username et son mot de passe, puis clique sur le bouton "Cr√©er un compte". Il devrait √™tre redirig√© vers la homepage.
- **Sc√©nario 2** : L'utilisateur saisit un username d√©j√† existant, puis clique sur le bouton "Cr√©er un compte". Il devrait voir un message d'erreur indiquant que le username est d√©j√† pris.
- **Sc√©nario 3** : L'utilisateur saisit un username valide et un mot de passe invalide, puis clique sur le bouton "Cr√©er un compte". Il devrait voir un message d'erreur.

### D√©termination des cas de test


Un cas de test est une instance sp√©cifique d'un sc√©nario de test. Il inclut des donn√©es d'entr√©e pr√©cises, des actions d√©taill√©es, et des r√©sultats attendus. Un sc√©nario de test peut avoir plusieurs cas de test pour couvrir diff√©rentes variations et conditions.


Pour chaque sc√©nario identifi√©, d√©terminez les cas de test √† ex√©cuter. 

Pour couvrir les tests du cas d'utilisation "Cr√©er un compte utilisateur", vous pourriez d√©finir les cas de test suivants :

#### Sc√©nario 1 : L'utilisateur saisit son username et son mot de passe, puis clique sur le bouton "Cr√©er un compte". Il devrait √™tre redirig√© vers la homepage.

- **Cas de test 1.1** : Saisir un username et un mot de passe valides, puis cliquer sur le bouton "Cr√©er un compte". V√©rifier que l'utilisateur est redirig√© vers la homepage.


#### Sc√©nario 2 : L'utilisateur saisit un username d√©j√† existant, puis clique sur le bouton "Cr√©er un compte". Il devrait voir un message d'erreur indiquant que le username est d√©j√† pris.

- **Cas de test 2.1** : Saisir un username d√©j√† existant et un mot de passe valide, puis cliquer sur le bouton "Cr√©er un compte". V√©rifier que l'utilisateur voit un message d'erreur indiquant que le username est d√©j√† pris.
- **Cas de test 2.2** : Saisir un username d√©j√† existant et laisser le champ mot de passe vide, puis cliquer sur le bouton "Cr√©er un compte". V√©rifier que l'utilisateur voit un message d'erreur indiquant que le mot de passe est requis.

#### Sc√©nario 3 : L'utilisateur saisit un username valide et un mot de passe invalide, puis clique sur le bouton "Cr√©er un compte". Il devrait voir un message d'erreur.

- **Cas de test 3.1** : Saisir un username valide et un mot de passe trop court, puis cliquer sur le bouton "Cr√©er un compte". V√©rifier que l'utilisateur voit un message d'erreur indiquant que le mot de passe est trop court.
- **Cas de test 3.2** : Saisir un username valide et laisser le champ mot de passe vide, puis cliquer sur le bouton "Cr√©er un compte". V√©rifier que l'utilisateur voit un message d'erreur indiquant que le mot de passe est requis.


# <InternalPageTitle> Comment mettre en place les tests e2e avec Playwright ? </InternalPageTitle>

## Introduction

Playwright est un outil moderne et puissant pour √©crire des tests e2e pour les applications web et mobiles. Il offre de nombreuses fonctionnalit√©s avanc√©es, comme la prise en charge des applications PWA, des tests parall√®les et la possibilit√© de tester sur plusieurs navigateurs.

Pour mettre en place les tests e2e avec Playwright, vous devez suivre quelques √©tapes :
- **Installation de Playwright** : Commencez par installer Playwright et les d√©pendances n√©cessaires. Pour utiliser Playwright, nous vous recommandons de cr√©er un nouveau projet ; vous pourriez l'int√©grer dans le frontend de votre application, mais nous vous conseillons de le garder s√©par√© pour des raisons de clart√©.
- **√âcriture des tests** : √âcrivez les tests e2e en utilisant l'API de Playwright pour simuler le comportement de l'utilisateur.


## Installation des d√©pendances

Pour ce tutorial, veuillez cr√©er un nouveau r√©pertoire `e2e-tests` sur base d'un copier / coller de `ci` : [ci](https://github.com/e-vinci/cae-theory-demos/tree/main/ci).

Une fois votre r√©pertoire `e2e-tests` cr√©√©, veuillez d√©marrer l'API et le frontend de la pizzeria du projet `e2e-tests`.

Pour ce tutoriel, au sein du r√©pertoire `e2e-tests`, nous allons cr√©er un projet de tests e2e avec Playwright et nommer ce projet `e2e`.  
Pour ce faire, cr√©ez un r√©pertoire nomm√© `e2e` au sein du r√©pertoire `e2e-tests` et placez-vous dedans.

Pour utiliser Playwright, vous devez installer les d√©pendances suivantes au sein de `e2e-tests/e2e` :

```bash
npm init playwright@latest
```

Veuillez suivre les instructions et s√©lectionnez toutes les options par d√©faut :
- le langage de programmation : TypeScript
- `Where to put your end-to-end tests?` : `tests` (c'est le dossier o√π seront stock√©s les tests e2e)
- `Add a GitHub Actions workflow?` : false (pour ajouter un workflow GitHub Actions pour ex√©cuter les tests e2e)
- `Install Playwright browsers (can be done manually via 'npx playwright install')?` : true (pour installer les navigateurs pris en charge par Playwright)

Une fois l'installation termin√©e, vous devriez voir un nouveau r√©pertoire `tests` dans votre projet `e2e` et un fichier `playwright.config.ts` √† la racine du projet.

`playwright.config.ts` : Ce fichier contient la configuration de Playwright pour les tests e2e. Vous pouvez personnaliser cette configuration en fonction de vos besoins, notamment pour d√©finir les navigateurs √† utiliser, les options de lancement, ou les param√®tres de test.

Le r√©pertoire `tests` contient un fichier `example.spec.ts` qui donne un exemple de test e2e avec Playwright. Vous pouvez le modifier ou le supprimer selon vos besoins.


## Ex√©cution des tests

### Ex√©cution des tests e2e dans le terminal 

Pour ex√©cuter les tests e2e avec Playwright en mode headless, c'est-√†-dire sans interface graphique, vous pouvez utiliser la commande suivante :

```bash
npx playwright test
```

Les r√©sultats des tests s'afficheront dans la console, indiquant si les tests ont r√©ussi ou √©chou√©. 

Veuillez taper cette commande dans le r√©pertoire `e2e` de votre projet.

Playwright d√©tecte toutes les sp√©cifications de tests se trouvant dans le r√©pertoire `tests`.

La seule sp√©cification de test fournie par d√©faut est `example.spec.ts` qui contient deux tests. Comme par d√©faut il y a 3 browsers install√©s, les tests seront ex√©cut√©s sur ces 3 navigateurs, √† savoir Chromium, Firefox et WebKit.  
C'est pourquoi, au sein du terminal, vous verrez que 6 tests ont pass√©. C'est en fait que 2 tests ont pass√© avec succ√®s sur chacun des 3 navigateurs.

### Execution des tests e2e dans le mode UI

Pour ex√©cuter les tests e2e dans le mode UI, vous pouvez utiliser la commande suivante :

```bash
npx playwright test --ui
```

Cette commande ouvre une interface graphique qui vous permet de visualiser les tests en cours d'ex√©cution et de voir les r√©sultats en temps r√©el.

Veuillez lancer les tests √† l'aide de l'UI.

### Ex√©cution de tests au sein de VS Code

VS Code a une extension Playwright qui permet d'ex√©cuter les tests e2e directement dans l'√©diteur. Pour utiliser cette extension, vous devez l'installer √† partir du marketplace des extensions de VS Code.  
Pour ce faire, veuillez suivre les √©tapes suivantes :
- Ouvrez VS Code
- Cliquez sur l'ic√¥ne des extensions dans la barre lat√©rale gauche
- Recherchez "Playwright" dans la barre de recherche
- Cliquez sur "Installer" pour installer l'extension `Playwright Test for VSCode `


Une fois l'extension install√©e, vous pouvez configurer et ex√©cuter les tests e2e directement dans VS Code en cliquant sur l'ic√¥ne "Testing" dans la barre lat√©rale gauche.

Pour configurer les tests, vous devez cliquer sur l'onglet "Playwright" dans la barre lat√©rale gauche.

Par exemple, veuillez s√©lectionner seulement le navigateur Chromium pour ex√©cuter les tests.

Vous pouvez ensuite lancer les tests soit :
- via le `Test Explorer` : en cliquant sur le bouton `Run Test`
- via le fichier `example.spec.ts` : en cliquant sur le bouton `Run` √† c√¥t√© du mot cl√© `test` ou `describe`.

Pour en savoir plus, veuillez consulter la documentation : https://playwright.dev/docs/getting-started-vscode


## Rapports de tests au format HTML

Par d√©faut, si certains tests √©chouent, Playwright g√©n√®re un rapport de tests au format HTML dans le r√©pertoire `test-results` et ouvre automatiquement ce rapport.

Il est possible de visualiser le rapport de tests en tapant la commande suivante :

```sh
npx playwright show-report
```

Une fa√ßon de visualiser le rapport de tests est de consulter le fichier `playwright-report/index.html` dans votre navigateur.

# <InternalPageTitle> O√π enregistrer les sp√©cifications de test ? </InternalPageTitle>

Playwright d√©tecte toutes les sp√©cifications de tests se trouvant dans le r√©pertoire `tests` par d√©faut. Vous pouvez personnaliser ce r√©pertoire dans le fichier `playwright.config.ts` en modifiant la propri√©t√© `testDir`.

Vous pouvez ajouter d'autres sp√©cifications de test en cr√©ant de nouveaux fichiers `*.spec.ts` dans le r√©pertoire `tests`.

Pour apprendre √† √©crire des tests e2e avec Playwright, veuillez lire la documentation officielle : https://playwright.dev/docs/writing-tests


# <InternalPageTitle> Comment tester une application web avec Playwright ? </InternalPageTitle>

## Introduction

Nous souhaitons tester une application web avec Playwright. Pour ce tutorial, nous souhaitons tester la cr√©ation d'un compte utilisateur sur une application web.

Pour ce faire, vous devez avoir d√©marr√© l'application web que vous souhaitez tester. 
Veuillez d√©marrer l'api du site de la pizzeria et le frontend de la pizzeria :
- Pour l'API, vous devez d'abord d√©marrer la DB localement √† l'aide de Docker Compose (ou Docker Desktop). Veuillez d√©marrer la derni√®re version de l'API en utilisant la commande `npm run dev` dans le r√©pertoire `/e2e-tests/api`.
- Pour le frontend, vous devez d√©marrer la derni√®re version du frontend de la pizzeria en utilisant la commande `npm run dev` dans le r√©pertoire `/e2e-tests/frontend`.

## √âcriture des tests

Pour tester le register d'un utilisateur sur une application web, vous pouvez √©crire des tests e2e avec Playwright. 

Veuillez cr√©er une nouvelle sp√©cification de test dans le r√©pertoire `tests` de votre projet `/e2e-tests/e2e` en cr√©ant un fichier `register.spec.ts`.

Nous allons commencer par ce sc√©nario : `Sc√©nario 1 - "Register OK" : L'utilisateur clic sur "Cr√©er un utilisateur", saisit son username et son mot de passe, puis clique sur le bouton "Cr√©er le compte". Il devrait √™tre redirig√© vers la homepage.`.

Pour un sc√©nario donn√©, vous pouvez d√©finir plusieurs cas de test. Nous allons commencer par ce premier cas de test : `Cas de test 1.1 : Naviguer vers "Cr√©er un utilisateur", saisir un username et un mot de passe valides, puis cliquer sur le bouton "Cr√©er le compte". V√©rifier que l'utilisateur est redirig√© vers la homepage et que l'on affiche son username`.

Voici le code de la sp√©cification de test `register.spec.ts` pour ce cas de test :

```ts
import { test, expect } from "@playwright/test";

test.describe("Register", () => {
  test("TC1.1: should register a new user when valid username & password", async ({
    page,
  }) => {
    const username = "ananda";
    const password = "123456";

    await page.goto("http://localhost:5173/");

    await page.getByText("cr√©er un utilisateur").click();

    await expect(page).toHaveURL("http://localhost:5173/register");

    await page.getByRole("textbox", { name: "username" }).fill(username);
    await page.getByRole("textbox", { name: "password" }).fill(password);
    await page.getByRole("button", { name: "Cr√©er le compte" }).click();

    await expect(page.getByText(`Hello dear ${username}`)).toBeVisible();
  });
});
```

Quelques explications sur ce code :
- **`test.describe`** : Cette fonction permet de d√©finir un groupe de tests. Dans notre cas, nous avons un groupe de tests pour tous les sc√©narios associ√©s au cas d'utilisation "Cr√©er un compte" (ou "Register").
- **`test`** : Cette fonction permet de d√©finir un test individuel. Dans notre cas, nous avons un test pour le cas de test 1.1.
- **`page.goto`** : Cette fonction permet de naviguer vers une URL sp√©cifique. Dans notre cas, nous naviguons vers la page d'accueil de l'application.
- **`page.getByText`** : Cette fonction permet de s√©lectionner un √©l√©ment de la page par son texte. Dans notre cas, nous s√©lectionnons le bouton "cr√©er un utilisateur". Par d√©faut, la recherche est insensible √† la casse.
- **`expect(page).toHaveURL`** : Cette fonction permet de v√©rifier que l'URL de la page correspond √† une valeur sp√©cifique. Dans notre cas, nous v√©rifions que l'utilisateur est redirig√© vers la page de register.
- **`page.getByRole`** : Cette fonction permet de s√©lectionner un √©l√©ment de la page par son r√¥le. Dans notre cas, nous s√©lectionnons les champs de texte pour le username et le mot de passe, ainsi que le bouton "Cr√©er le compte".
- **`locator.fill`** : Cette fonction permet de remplir un champ de texte avec une valeur sp√©cifique. Dans notre cas, nous remplissons les champs de texte avec le username et le mot de passe. Un `locator` est un objet qui repr√©sente un √©l√©ment de la page.
- **`locator.click`** : Cette fonction permet de cliquer sur un √©l√©ment de la page. Dans notre cas, nous cliquons sur le bouton "Cr√©er le compte".
- **`expect(page.getByText).toBeVisible`** : Cette fonction permet de v√©rifier que l'√©l√©ment de la page est visible. Dans notre cas, nous v√©rifions que le message de bienvenue contenant le username est affich√©.

Nous avons √©crit un test pour le cas de test 1.1. Ce test fonctionne une seule fois pour un username et un mot de passe donn√©s.  
Comment pourrions-nous √©crire un test qui fonctionne √† chaque fois ?
Pour ce faire, il faudrait pouvoir supprimer l'utilisateur cr√©√© √† la fin du test : nous pourrions, par exemple, utiliser une fonction **`afterEach`** qui serait ex√©cut√©e apr√®s chaque test. Cette fonction permettrait de nettoyer l'√©tat de l'application apr√®s chaque test. N√©anmoins, pour supprimer un utilisateur, il faudrait que l'API de l'application web permette de supprimer un utilisateur. Ce genre d'op√©ration est g√©n√©ralement r√©serv√© aux administrateurs, elle demanderait donc une authentification. Ce qui est un peu plus complexe √† mettre en place.

Pour simplifier, nous pourrions simplement g√©n√©rer un username al√©atoire √† chaque test. Pour ce faire, nous allons utiliser la librairie `faker` qui permet de g√©n√©rer des donn√©es al√©atoires.

Pour installer la librairie `faker`, veuillez taper la commande suivante :

```bash
npm install @faker-js/faker -D
```

Toutes les API de `faker` sont disponibles ici : https://fakerjs.dev/api/

Voici le code mis √† jour pour le cas de test 1.1 :

```ts {2,8-9} showLineNumbers
import { test, expect } from "@playwright/test";
import { faker } from "@faker-js/faker";

test.describe("Register", () => {
  test("TC1.1: should register a new user when valid username & password", async ({
    page,
  }) => {
    const username = faker.internet.username();
    const password = faker.internet.password();

    await page.goto("http://localhost:5173/");

    await page.getByText("cr√©er un utilisateur").click();

    await expect(page).toHaveURL("http://localhost:5173/register");

    await page.getByRole("textbox", { name: "username" }).fill(username);
    await page.getByRole("textbox", { name: "password" }).fill(password);
    await page.getByRole("button", { name: "Cr√©er le compte" }).click();
    
    await expect(page.getByText(`Hello dear ${username}`)).toBeVisible();
  });
});
```

Dans ce code, nous utilisons la fonction **`faker.internet.username()`** pour g√©n√©rer un username al√©atoire et la fonction **`faker.internet.password()`** pour g√©n√©rer un mot de passe al√©atoire.  
Notons que `faker` permet de configurer les donn√©es g√©n√©r√©es. Par exemple, pour g√©n√©rer un username sur base d'un username, vous pouvez utiliser `faker.internet.username({firstName:"ananda"})`.

# <InternalPageTitle> Comment s'assurer de l'√©tat de l'application avant de commencer les tests ? </InternalPageTitle>

Notons que dans pas mal de tests, on peut consid√©rer qu'il soit important de d√©marrer une suite de test avec un √©tat initial connu. 

Il existe pas mal de solutions pour obtenir un √©tat initial connu avant de commencer les tests. 

## M√©thode 1 : Utiliser des hooks de tests et des op√©rations d'API

### Introduction

Il est possible d'utiliser des hooks de test comme **`beforeAll`** et **`beforeEach`** pour r√©initialiser la base de donn√©es avant chaque suite de tests ou chaque test individuel.

### Utilisation de la fonction `beforeAll`

On peut utiliser la fonction **`beforeAll`** qui permet d'ex√©cuter une fonction avant le d√©but de la suite de tests. Cette fonction permet de mettre en place l'√©tat initial de l'application avant de commencer les tests.  
Par exemple, nous pourrions avoir une fonction de l'API qui permet de supprimer tous les utilisateurs de la base de donn√©es. Cette fonction pourrait √™tre appel√©e dans la fonction **`beforeAll`** pour s'assurer que la base de donn√©es est vide avant de commencer les tests. Attention donc √† bien s√©curiser cette op√©ration par une authentification JWT et vous assurer que l'op√©ration n'est accessible qu'en environnement de test.

L'avantage de cette m√©thode est :
- que vous pouvez √™tre s√ªr de l'√©tat initial de l'application avant de commencer les tests.
- que vous pouvez garantir que les tests sont reproductibles et fiables. 
- que vous pouvez √©crire des cas de tests avec des donn√©es pr√©cises et connues. Il n'est pas n√©cessaire de g√©n√©rer des donn√©es al√©atoires pour chaque test.

L'inconv√©nient de cette m√©thode est :
- que vous devez vous assurer que l'√©tat initial de l'application est coh√©rent avec les tests que vous souhaitez ex√©cuter. Si l'√©tat initial de l'application ne correspond pas aux tests, les tests peuvent √©chouer.
- pas si simple √† mettre en place si l'application est complexe et que l'√©tat initial d√©pend de plusieurs facteurs.

### Utilisation de la fonction `afterEach`

Il est possible d'utiliser la fonction **`afterEach`** qui permet d'ex√©cuter une fonction apr√®s chaque test. Cette fonction permet de nettoyer l'√©tat de l'application apr√®s chaque test.

L'avantage de cette m√©thode est :
- que vous pouvez nettoyer l'√©tat de l'application apr√®s chaque test pour garantir que les tests sont ind√©pendants les uns des autres.
- que vous pouvez √©viter les effets de bord et les interactions inattendues entre les tests.

L'inconv√©nient de cette m√©thode est :
- que vous devez vous assurer que le nettoyage de l'√©tat de l'application est correctement impl√©ment√©. Si le nettoyage n'est pas correct, les tests peuvent √©chouer.
- que vous devez g√©rer les cas o√π le nettoyage de l'√©tat de l'application √©choue. Si le nettoyage √©choue, les tests peuvent √©chouer.
- pas si simple √† mettre en place.


## M√©thode 2 : Utiliser des scripts de r√©initialisation de la base de donn√©es

### Introduction

Il est possible d'utiliser des scripts de r√©initialisation de la base de donn√©es pour r√©initialiser l'√©tat de la base de donn√©es avant de commencer les tests. Ces scripts peuvent √™tre ex√©cut√©s manuellement ou automatiquement avant le d√©but des tests.

### Utilisation de scripts de r√©initialisation de la base de donn√©es

Nous allons maintenant voir comment mettre √† jour l'API se trouvant dans le dossier `api` de notre r√©pertoire `e2e-tests` pour r√©initialiser la base de donn√©es avant de commencer les tests.

#### Fonctionnement actuel de l'initialisation de la DB

Le script **`insert.sql`** dans le r√©pertoire **`src/main/resources`** de l'API : 
- est ex√©cut√© automatiquement par Spring Boot gr√¢ce √† la configuration de la source de donn√©es. 
- Spring Boot d√©tecte automatiquement les fichiers SQL dans ce r√©pertoire et les ex√©cute au d√©marrage de l'application.  

Voici comment cela fonctionne :  
- **Configuration de la source de donn√©es** : 
  - Dans le fichier **`application.properties`**, vous avez configur√© les propri√©t√©s de la source de donn√©es (username, password...), ce qui permet √† Spring Boot de se connecter √† la base de donn√©es.  
  - **`spring.jpa.generate-ddl=true`** : cette propri√©t√© permet √† Spring Boot de g√©n√©rer automatiquement le sch√©ma de la base de donn√©es √† partir des entit√©s JPA.
- **Ex√©cution automatique des scripts SQL** : 
  - Spring Boot, par d√©faut, ex√©cute les scripts SQL trouv√©s dans **`src/main/resources`** ou **`src/main/resources/db/migration`** au d√©marrage de l'application **SEULEMENT** pour les bases de donn√©es int√©gr√©es (par pour PostGres). 
  - Pour ex√©cuter les scripts SQL √† chaque d√©marrage, il faut ajouter la propri√©t√© **`spring.sql.init.mode=always`** dans le fichier **`application.properties`**.
  - Les fichiers doivent √™tre nomm√©s **`schema.sql`** pour les scripts de cr√©ation de sch√©ma et **`data.sql`** pour les scripts d'insertion de donn√©es.
  - Cependant, il ex√©cutera √©galement tout autre fichier SQL trouv√© dans ce r√©pertoire.
  - Pour laisser d'abord Spring Boot g√©n√©rer le sch√©ma de la base de donn√©es avant d'ex√©cuter **`data.sql`**, il faut ajouter la propri√©t√© **`spring.jpa.defer-datasource-initialization=true`** dans le fichier **`application.properties`**.  
  Si cela n'est pas fait, Spring Boot ex√©cutera **`data.sql`** avant de g√©n√©rer le sch√©ma de la base de donn√©es, ce qui peut entra√Æner des erreurs.

Veuillez donc mettre √† jour le fichier **`application.properties`** pour ajouter ces propri√©t√©s :

```properties {9-10}
spring.application.name=demo

server.port=3000

spring.datasource.url=jdbc:postgresql://localhost:5432/cae_db
spring.datasource.username=cae_user
spring.datasource.password=cae
spring.jpa.generate-ddl=true
spring.sql.init.mode=always
spring.jpa.defer-datasource-initialization=true
```

Pour bien faire, renommez le fichier **`src/main/resources/insert.sql`** en **`src/main/resources/data.sql`**.

D√©marrez l'API et v√©rifiez que la base de donn√©es est bien initialis√©e.

Actuellement, √† chaque d√©marrage de l'API, on insert un utilisateur `admin` dans la DB.
Voici le contenu actuel du fichier **`data.sql`** :

```sql
INSERT INTO users(username, password) VALUES('admin', '$2y$10$EW75BdcbCfKEA3NbE7in4OiYYacfP3OY4Q2JsVzjxd3jNxxgAEZNu');
```

Cela va vite devenir probl√©matique car comme la DB est r√©initialis√©e √† chaque d√©marrage de l'API, on va se retrouver avec plusieurs utilisateurs `admin` dans la DB. En effet, `username` n'est pas une cl√© primaire.

Pour r√©initialiser la base de donn√©es avant de commencer les tests, nous allons modifier le script SQL pour supprimer tous les utilisateurs de la base de donn√©es avant d'en ajouter un.

Veuillez modifier le contenu du fichier **`data.sql`** :

```sql
TRUNCATE TABLE users;

INSERT INTO users(username, password)
VALUES ('admin', '$2y$10$EW75BdcbCfKEA3NbE7in4OiYYacfP3OY4Q2JsVzjxd3jNxxgAEZNu');
```

Le probl√®me avec cette approche, c'est que l'on ne veut pas r√©initialiser la DB √† chaque d√©marrage de l'API, mais uniquement avant de commencer les tests.  
En effet, imaginez que l'API soit utilis√©e en production, on ne veut pas supprimer tous les utilisateurs √† chaque d√©marrage de l'API üò±.

#### R√©initialisation de la base de donn√©es avant de commencer les tests

Pour ce tutoriel, nous allons cr√©er deux configurations pour l'API : une configuration pour l'environnement de production et une configuration pour l'environnement de test.

Pour ce faire, veuillez cr√©er un nouveau fichier **`application-test.properties`** dans le r√©pertoire **`src/main/resources`** :

```properties {9-10}
spring.application.name=demo

server.port=3000

spring.datasource.url=jdbc:postgresql://localhost:5432/cae_db
spring.datasource.username=cae_user
spring.datasource.password=cae
spring.jpa.generate-ddl=true
spring.sql.init.mode=always
spring.jpa.defer-datasource-initialization=true
```

Nous allons mettre √† jour le fichier **`application.properties`** pour qu'il n'utilise jamais de script SQL pour initialiser la base de donn√©es :

```properties {9}
spring.application.name=demo

server.port=3000

spring.datasource.url=jdbc:postgresql://localhost:5432/cae_db
spring.datasource.username=cae_user
spring.datasource.password=cae
spring.jpa.generate-ddl=true
spring.sql.init.mode=never
```

Si nous red√©marrons l'application maintenant via la configuration nomm√©e **`DemoApplication`** au sein d'IntelliJ, la base de donn√©es ne sera pas r√©initialis√©e.

De m√™me, si nous ex√©cutons cette commande :

```bash
mvn clean spring-boot:run
```

La base de donn√©es ne sera pas r√©initialis√©e.

Pour r√©initialiser la base de donn√©es avant de commencer les tests, nous pouvons activer le profile de tests dans la commande de lancement de Spring Boot :

```bash
mvn clean spring-boot:run -Dspring-boot.run.profiles=test
```

C'est donc cette commande que nous allons utiliser pour d√©marrer l'API avant de commencer les tests.

Une autre possibilit√©, c'est de g√©n√©rer un package JAR ex√©cutable et de lancer l'application avec le profile de tests :

```bash
mvn clean package
java -jar ./target/cae-exercices-demo-0.0.1-SNAPSHOT.jar --spring.profiles.active=test
```

Si vous lancez l'application avec le JAR, il est possible que le nom du fichier soit diff√©rent. Veuillez v√©rifier le nom du fichier g√©n√©r√© dans le r√©pertoire **`target`**.

# <InternalPageTitle> Comment g√©rer les duplications de code dans les tests ? </InternalPageTitle>

## Introduction

Il est important de g√©rer les duplications de code dans les tests pour √©viter la r√©p√©tition et am√©liorer la maintenabilit√© des tests. Les duplications de code peuvent rendre les tests difficiles √† lire, √† maintenir et √† d√©boguer.

Il existe plusieurs techniques pour g√©rer les duplications de code dans les tests :
- **Utiliser des fonctions utilitaires** : Cr√©ez des fonctions utilitaires pour les actions r√©p√©titives dans les tests. Ces fonctions peuvent √™tre r√©utilis√©es dans plusieurs tests pour √©viter la duplication de code.
- **Utiliser des fonctions de setup et de teardown** : Utilisez des fonctions de setup et de teardown pour les actions qui doivent √™tre ex√©cut√©es avant et apr√®s les tests. Ces fonctions permettent de r√©duire la duplication de code en centralisant les actions communes. Ces fonctions sont : **`beforeEach`**, **`afterEach`**, **`beforeAll`** et **`afterAll`**.
- **Utiliser des fixtures** : Cr√©ez des fixtures pour les donn√©es et les √©tats de l'application qui sont utilis√©s dans plusieurs tests. Les fixtures permettent de centraliser les donn√©es et les √©tats de l'application pour √©viter la duplication de code. N'h√©sitez pas √† consulter la documentation de Playwright pour en savoir plus sur les fixtures : https://playwright.dev/docs/test-fixtures

## Suite des tests pour le register

Nous allons voir comment g√©rer les duplications de code dans les tests pour le register d'un utilisateur sur une application web.

Nous allons commencer par ce sc√©nario : `Sc√©nario 2 - "Register KO" : L'utilisateur clic sur "Cr√©er un utilisateur", saisit un username d√©j√† existant, puis clique sur le bouton "Cr√©er le compte". Il devrait voir un message d'erreur indiquant que le username est d√©j√† pris.`.

Nous allons commencer par ce cas de test : `Cas de test 2.1 : Saisir un username d√©j√† existant et un mot de passe valide, puis cliquer sur le bouton "Cr√©er un compte". V√©rifier que l'utilisateur voit un message d'erreur indiquant que le username est d√©j√† pris.`

Ici, l'UI ne permet actuellement pas d'afficher un message d'erreur si le username est d√©j√† pris. N√©anmoins, un message d'erreur est affich√© dans la console du navigateur √† l'aide de **`console.error()`**. 

Voici le code la **`RegisterPage`** :

```tsx
const handleSubmit = async (e: SyntheticEvent) => {
    e.preventDefault();
    try {
      await registerUser({ username, password });
      navigate('/');
    } catch (err) {
      console.error('RegisterPage::error: ', err);
    }
  };
```

Nous savons que lorsqu'un utilisateur est d√©j√† pr√©sent dans l'API, un message d'erreur est affich√© dans la console du navigateur qui affichera le HTTP status code 409.

Nous allons donc v√©rifier que ce message d'erreur est bien affich√© dans la console du navigateur.

Pensez √† bien r√©initialiser la base de donn√©es avant de commencer les tests. Pour ce faire, dans le r√©pertoire `/e2e-tests/api`, veuillez red√©marrer l'API avec la commande suivante :

```bash
mvn clean spring-boot:run -Dspring-boot.run.profiles=test
```

Pensez aussi a bien garder le frontend de la pizzeria en ex√©cution.

Voici le code de la sp√©cification de test `register.spec.ts` que vous devez mettre √† jour pour ce cas de test :

```ts {24-60} showLineNumbers
import { test, expect } from "@playwright/test";
import { faker } from "@faker-js/faker";

test.describe("Register", () => {
  test("TC1.1: should register a new user when valid username & password", async ({
    page,
  }) => {
    const username = faker.internet.username();
    const password = faker.internet.password();

    await page.goto("http://localhost:5173/");

    await page.getByText("cr√©er un utilisateur").click();

    await expect(page).toHaveURL("http://localhost:5173/register");

    await page.getByRole("textbox", { name: "username" }).fill(username);
    await page.getByRole("textbox", { name: "password" }).fill(password);
    await page.getByRole("button", { name: "Cr√©er le compte" }).click();

    await expect(page.getByText(`Hello dear ${username}`)).toBeVisible();
  });

  test("TC2.1: should not register a new user when existing username", async ({
    page,
  }) => {
    const username = "farina";
    const password = "farinapwd";

    await page.goto("http://localhost:5173/");

    await page.getByText("cr√©er un utilisateur").click();

    await expect(page).toHaveURL("http://localhost:5173/register");

    await page.getByRole("textbox", { name: "username" }).fill(username);
    await page.getByRole("textbox", { name: "password" }).fill(password);
    await page.getByRole("button", { name: "Cr√©er le compte" }).click();

    await expect(page.getByText(`Hello dear ${username}`)).toBeVisible();

    await page.getByText("se d√©connecter").click();

    await page.getByText("cr√©er un utilisateur").click();

    await expect(page).toHaveURL("http://localhost:5173/register");

    await page.getByRole("textbox", { name: "username" }).fill(username);
    await page.getByRole("textbox", { name: "password" }).fill(password);
    await page.getByRole("button", { name: "Cr√©er le compte" }).click();

    // Check in the console for the error message
    const message = await page.waitForEvent(
      "console",
      (msg) => msg.type() === "error"
    );

    // Check for specific error message
    expect(message.text()).toContain("409");
  });
});
```

**`page.waitForEvent`** permet d'attendre un √©v√©nement donn√©. Dans notre cas, nous attendons un √©v√©nement de type **`console`**. Nous v√©rifions ensuite que le message d'erreur contient le code d'erreur **`409`**.

Nous voyons qu'il y a pas mal de duplications de code dans les tests. Nous allons voir comment g√©rer ces duplications de code.

Attention, ces deux cas cr√©ent deux utilisateurs dans la base de donn√©es. Le deuxi√®me sc√©nario de test cr√©e une utilisatrice `farina` et le premier sc√©nario de test cr√©e un utilisateur al√©atoire. Il est donc possible que le deuxi√®me sc√©nario de test √©choue si l'utilisateur `farina` est d√©j√† pr√©sent dans la base de donn√©es. Cela va arriver si vous ex√©cutez les tests sur les 3 browsers en m√™me temps. Pour √©viter cela, vous pouvez ex√©cuter les tests sur un seul browser √† la fois.

## Configuration d'un seul browser

Pour ex√©cuter les tests sur un seul browser, vous pouvez modifier la propri√©t√© **`projects`** dans le fichier **`playwright.config.ts`** :

```ts
//...
 projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
],
```


## Utilisation de fonctions utilitaires

Nous allons commencer par extraire le code commun dans deux fonctions utilitaires.  
Pour ce faire, veuillez cr√©er un nouveau fichier `helper.ts` dans le r√©pertoire `tests` de votre projet `e2e` et y ajouter le code suivant :

```ts
import { Page, expect } from "@playwright/test";

const goFromHomePageToRegisterPage = async (page: Page) => {
  await page.goto("http://localhost:5173/");
  await page.getByText("cr√©er un utilisateur").click();
  await expect(page).toHaveURL("http://localhost:5173/register");
};

const registerWith = async (page: Page, username: string, password: string) => {
  await page.getByRole("textbox", { name: "username" }).fill(username);
  await page.getByRole("textbox", { name: "password" }).fill(password);
  await page.getByRole("button", { name: "Cr√©er le compte" }).click();
};

export { registerWith, goFromHomePageToRegisterPage };
```

Dans ce code, nous avons cr√©√© deux fonctions utilitaires :
- **`goFromHomePageToRegisterPage`** : Cette fonction permet de naviguer de la HomePage √† la page de register.
- **`registerWith`** : Cette fonction permet de remplir les champs de texte pour le username et le mot de passe, puis de cliquer sur le bouton "Cr√©er le compte".

Nous allons maintenant mettre √† jour les tests pour utiliser ces fonctions utilitaires. Voici le code mis √† jour de la sp√©cification de test `register.spec.ts` :

```ts {3,9,13,21,25,31} showLineNumbers
import { test, expect } from "@playwright/test";
import { faker } from "@faker-js/faker";
import { goFromHomePageToRegisterPage, registerWith } from "./helper";

test.describe("Register", () => {
  test("TC1.1: should register a new user when valid username & password", async ({
    page,
  }) => {
    goFromHomePageToRegisterPage(page);

    const username = faker.internet.username();
    const password = faker.internet.password();
    await registerWith(page, username, password);

    await expect(page.getByText(`Hello dear ${username}`)).toBeVisible();
  });

  test("TC2.1: should not register a new user when existing username", async ({
    page,
  }) => {
    goFromHomePageToRegisterPage(page);

    const username = "farina";
    const password = "farinapwd";
    await registerWith(page, username, password);

    await expect(page.getByText(`Hello dear ${username}`)).toBeVisible();

    await page.getByText("se d√©connecter").click();

    goFromHomePageToRegisterPage(page);

    await registerWith(page, username, password);

    // Check in the console for the error message
    const message = await page.waitForEvent(
      "console",
      (msg) => msg.type() === "error"
    );

    // Check for specific error message
    expect(message.text()).toContain("409");
  });
});
``` 

## Utilisation de fonctions de setup et de teardown

Nous allons maintenant voir comment utiliser une fonction de setup pour r√©duire les duplications de code dans les tests.

Dans les deux cas de test que nous avons √©crits, et dans tous les cas de tests associ√© au register, nous devons √† chaque fois nous rendre sur la HomePage, cliquer sur "cr√©er un utilisateur", puis nous rendre sur la page de register.

Nous allons donc utiliser une fonction de setup pour effectuer ces actions avant chaque test. Pour ce faire, nous allons utiliser la fonction **`beforeEach`** de Playwright.

Voici le code mis √† jour de la sp√©cification de test `register.spec.ts` :

```ts {5-8,12-13,20-23} showLineNumbers
import { test, expect } from "@playwright/test";
import { faker } from "@faker-js/faker";
import { goFromHomePageToRegisterPage, registerWith } from "./helper";

test.describe("Register", () => {
  test.beforeEach(async ({ page }) => {
    goFromHomePageToRegisterPage(page);
  });

  test("TC1.1: should register a new user when valid username & password", async ({
    page,
  }) => {
    const username = faker.internet.username();
    const password = faker.internet.password();
    await registerWith(page, username, password);

    await expect(page.getByText(`Hello dear ${username}`)).toBeVisible();
  });

  test("TC2.1: should not register a new user when existing username", async ({
    page,
  }) => {
    const username = "farina";
    const password = "farinapwd";
    await registerWith(page, username, password);

    await expect(page.getByText(`Hello dear ${username}`)).toBeVisible();

    await page.getByText("se d√©connecter").click();

    goFromHomePageToRegisterPage(page);

    await registerWith(page, username, password);

    // Check in the console for the error message
    const message = await page.waitForEvent(
      "console",
      (msg) => msg.type() === "error"
    );

    // Check for specific error message
    expect(message.text()).toContain("409");
  });
});
```

Dans ce code, nous avons utilis√© la fonction **`test.beforeEach`** pour ex√©cuter la fonction **`goFromHomePageToRegisterPage`** avant chaque test. Cette fonction permet de r√©duire les duplications de code en centralisant les actions communes.
De plus, elle permet de **garantir que les tests commencent dans un √©tat connu et coh√©rent**.

# <InternalPageTitle> Comment √©crire des tests e2e de qualit√© ? </InternalPageTitle>

Nous vous conseillons de suivre les bonnes pratiques de d√©veloppement pour √©crire des tests e2e de qualit√©. Voici quelques conseils pour √©crire des tests e2e robustes et fiables :
- **Utiliser des s√©lecteurs CSS sp√©cifiques** : Utilisez des s√©lecteurs CSS sp√©cifiques pour cibler les √©l√©ments de l'application que vous souhaitez tester. √âvitez d'utiliser des s√©lecteurs bas√©s sur la position des √©l√©ments dans la page, car ils sont plus susceptibles de changer.
- **G√©rer les attentes** : G√©rez les attentes dans vos tests e2e en utilisant des fonctions d'attente ou des assertions pour v√©rifier que les √©l√©ments de l'application sont dans l'√©tat attendu.
- **Nettoyer l'√©tat de l'application** : Assurez-vous de nettoyer l'√©tat de l'application entre chaque test pour √©viter les effets de bord et les interactions inattendues entre les tests.

Dans les prochaines sections, nous verrons comment int√©grer les tests e2e dans notre pipeline CI/CD pour garantir la qualit√© de nos applications.

# <InternalPageTitle> Comment int√©grer les tests e2e dans le pipeline de CI ? </InternalPageTitle>

## Introduction

Il est important d'int√©grer les tests e2e dans le pipeline de CI pour garantir la qualit√© de l'application et d√©tecter les probl√®mes le plus t√¥t possible. Les tests e2e permettent de valider le bon fonctionnement de l'application dans son ensemble et de v√©rifier que les diff√©rentes parties de l'application interagissent correctement.

Dans la suite du tutoriel `e2e-tests`, nous allons voir comment int√©grer les tests e2e avec Playwright dans le pipeline de CI √† l'aide de GitLab CI.

Pour ce faire, veuillez reprendre le repository de votre projet GitLab personnel (ou de votre projet GitLab associ√© √† un groupe pour un ou une membre d'un groupe d'√©tudiants Vinci) et suivre les √©tapes suivantes.

Veuillez copier / coller votre r√©pertoire `e2e` cr√©√© au tutoriel pr√©c√©dent (dont le chemin est `e2e-tests/e2e`) √† la racine du repository de votre projet GitLab. N'oubliez pas que vous devez pousser des modifications √† partir d'une nouvelle branche.  
A vous de jouer donc, de choisir un nom de branche.

## Configuration de GitLab CI

Dans le repository de votre projet GitLab, voici le contenu actuel du fichier `.gitlab-ci.yml` :

```yaml
api test:
  image: maven:3.9.9-amazoncorretto-21
  script:
    - cd api
    - mvn clean test
  artifacts:
    paths:
      - api/target/reports/
      - api/target/site/
      - api/target/surefire-reports/

frontend test:
  image: node:20
  script:
    - cd frontend
    - npm install
    - npm run lint
    - npm run coverage
  artifacts:
    paths:
      - frontend/coverage/
```

Veuillez mettre √† jour le fichier `.gitlab-ci.yml` et y ajouter le code suivant :

```yaml {1-3,6,18,29-57} showLineNumbers
stages:
  - test
  - e2e

api test:
  stage: test
  image: maven:3.9.9-amazoncorretto-21
  script:
    - cd api
    - mvn clean test
  artifacts:
    paths:
      - api/target/reports/
      - api/target/site/
      - api/target/surefire-reports/

frontend test:
  stage: test
  image: node:20
  script:
    - cd frontend
    - npm install
    - npm run lint
    - npm run coverage
  artifacts:
    paths:
      - frontend/coverage/

e2e tests:
  stage: e2e
  image: mcr.microsoft.com/playwright:v1.50.0-jammy
  services:
    - docker:dind
  variables:
    DOCKER_HOST: tcp://docker:2375
  before_script:   
    - apt update -y
    - wget https://download.oracle.com/java/21/latest/jdk-21_linux-x64_bin.deb
    - apt install ./jdk-21_linux-x64_bin.deb
    - apt install -y maven docker-compose-v2
    - docker compose -f api/docker-compose.yaml up --build -d
    - sleep 5
    - cd api
    - mvn clean spring-boot:run -Dspring-boot.run.profiles=test &
    - sleep 30
    - cd ../frontend
    - npm install
    - npm run dev &
    - sleep 30
    - cd ../e2e
    - npm install
  script:
    - npx playwright test
  artifacts:
    paths:
      - e2e/playwright-report/
      - e2e/test-results/
```

Dans ce fichier, nous avons deux **`stages`** : `test` et `e2e`. Le stage `test` contient les t√¢ches de test pour l'API et le frontend, tandis que le stage `e2e` contient les t√¢ches de test e2e avec Playwright.

Un **`stage`** dans GitLab CI permet de regrouper des t√¢ches en fonction de leur objectif. Les stages sont ex√©cut√©s en s√©rie, ce qui signifie que le stage `test` sera ex√©cut√© en premier, suivi du stage `e2e`.

Si l'on souhaite passer des fichiers d'un stage √† un autre, il est possible de le faire en utilisant les **`artifacts`**. Les **`artifacts`** sont des fichiers g√©n√©r√©s par les t√¢ches de CI qui peuvent √™tre utilis√©s dans d'autres t√¢ches. Nous verrons cela plus tard, lors du d√©ploiement d'applications.

Dans le stage `e2e`, nous utilisons l'image **`mcr.microsoft.com/playwright:v1.50.0-jammy`** pour ex√©cuter les tests e2e avec Playwright. Cette image contient Playwright et tous les navigateurs n√©cessaires pour ex√©cuter les tests e2e. Si vous tentez de cr√©er une image Docker avec Playwright, vous pouvez consulter la documentation officielle de Playwright : https://playwright.dev/docs/ci  
Il est important de noter que si vous tentez de construire votre propre image de Playwright, vous devrez √©galement installer les navigateurs n√©cessaires pour ex√©cuter les tests e2e, et cela rend la configuration tr√®s complexe.  
Dans notre cas, nous utilisons l'image officielle de Playwright qui contient pas mal de choses que nous avons besoin pour ex√©cuter les tests e2e.  
N√©anmoins, nous devons aussi rajouter des d√©pendances √† cette image :
- celles n√©cessaire √† l'API : Java et Maven. 
- Docker Compose pour pouvoir ex√©cuter la DB dans un conteneur.

Nous utilisons la variables **`DOCKER_HOST`** pour sp√©cifier l'h√¥te Docker √† utiliser dans le pipeline de CI. En utilisant **`docker:dind`**, nous pouvons ex√©cuter des conteneurs Docker dans le pipeline de CI. Toutes les commandes donn√©es dans le **`before_script`** seront ex√©cut√©es avant le script principal. Ces commandes s'ex√©cutent au sein de la pipeline de CI qui elle aussi s'ex√©cute dans un conteneur Docker. Ainsi, pour la DB, nous utilisons **`docker compose`** pour d√©marrer le conteneur de la DB.  
Comment est-ce que le conteneur de la pipeline de CI peut acc√©der √† la DB ?
- **R√©seau Docker** : Les conteneurs d√©marr√©s par docker compose partagent un r√©seau Docker par d√©faut. Le conteneur de la pipeline GitLab CI peut acc√©der √† ce r√©seau.
- **H√¥te Docker** : Pour acc√©der au conteneur de la DB depuis le conteneur de la pipeline (contenant l'API, le frontend et l'application Playwright de e2e), utilisez l'h√¥te **`docker`** au lieu de **`localhost`**. Cela permet au conteneur de la pipeline de se connecter au r√©seau Docker partag√©.

Veuillez donc mettre √† jour le fichier **`application-test.properties`** de l'API pour qu'il utilise **`docker`** comme h√¥te de la base de donn√©es :

```properties
spring.datasource.url=jdbc:postgresql://docker:5432/cae_db
```

Vous noterez que nous avons ajout√© une pause de 30 secondes apr√®s le d√©marrage de l'API et du frontend pour s'assurer qu'ils sont pr√™ts avant de commencer les tests e2e. Cette pause est n√©cessaire car le build de l'API et du frontend peut prendre un certain temps et les tests e2e peuvent √©chouer si l'API ou le frontend ne sont pas pr√™ts.

Une fois que c'est fait, vous pouvez pousser les modifications sur votre branche et cr√©er une Merge Request. Vos tests e2e devrait maintenant s'ex√©cuter dans le pipeline de CI.

Veuillez v√©rifier que la pipeline de CI s'ex√©cute correctement et que les tests e2e s'ex√©cutent sans erreur.

## Etat actuel de la pipeline de CI

Dans ce tutoriel, nous avons vu comment √©crire des tests e2e avec Playwright pour tester une application web. Nous avons vu comment √©crire des cas de test pour le register d'un utilisateur et comment g√©rer les duplications de code dans les tests. Nous avons √©galement vu comment int√©grer les tests e2e dans le pipeline de CI √† l'aide de GitLab CI.

Nous voyons que la mise en place de la pipeline de CI pour les tests e2e est un peu plus complexe que pour les tests unitaires et les tests d'int√©gration. Cela est d√ª au fait que les tests e2e n√©cessitent un environnement complet de l'application pour s'ex√©cuter. Il est donc important de bien configurer l'environnement de test pour garantir que les tests e2e s'ex√©cutent correctement.

Voici √† quoi correspond l'environnement de test pour notre pipeline acutel de CI :

<PlantUML src="/diagrams/iteration1-test-deployment.puml" alt="Environnement de ci actuel" />

La configuration actuelle contient quelques faiblesses :
- Les tests e2e s'ex√©cutent dans un seul navigateur. Il est important de tester l'application dans plusieurs navigateurs pour garantir la compatibilit√©.
- Nous utilisons une pause de 30 secondes pour attendre que l'API et le frontend soient pr√™ts. Cette pause n'est pas id√©ale et peut entra√Æner des probl√®mes si les services prennent plus de temps √† d√©marrer.
- Nous utilisons une image Docker pour ex√©cuter les tests e2e. Cette image contient notamment Playwright et les navigateurs n√©cessaires, mais elle peut √™tre complexe √† configurer et √† maintenir. 
- Nous devons √† chaque push de modification installer les d√©pendances n√©cessaires √† chaque job. Cela ralentit le pipeline de CI.
- Nous n'avons pas un seul r√©seau pour les diff√©rentes applications : la DB est sur un autre r√©seau que l'API, le frontend et les tests e2e. Cela peut poser des probl√®mes de communication entre les applications et rend la configuration des URLs pour communiquer plus complexe.
- Nous ne testons pas l'application dans son environnement de production. Il est important de tester l'application dans un environnement de production, une fois l'application d√©ploy√©e, pour garantir que tout fonctionne correctement pour les utilisateurs de l'application.
- Nous ne r√©utilisons pas le build d'un service (api & frontend) d'un stage √† l'autre. Cela peut ralentir le pipeline de CI.
- Les builds de l'API et du frontend sont des builds de d√©veloppement. Il est important de construire l'API et le frontend pour la production avant de les tester ; il faudra donc apprendre √† cr√©er des builds de production (lancer la commande `npm run build` par exemple au lieu de `npm run dev` pour le frontend) et √† les ex√©cuter. 

Nous allons prochainement voir que la contain√©risation des applications peut nous aider √† r√©soudre plusieurs de ces probl√®mes.

Mais avant cela, nous allons voir si nous pouvons optimiser la configuration actuelle de la pipeline de CI pour les tests e2e en utilisant le cache de GitLab CI.

# <InternalPageTitle> Comment utiliser le cache de GitLab CI ? </InternalPageTitle>

## Introduction

Le cache de GitLab CI permet de stocker des fichiers ou des r√©pertoires entre les diff√©rents jobs d'une pipeline de CI. Cela permet de r√©duire le temps de construction en √©vitant de t√©l√©charger les d√©pendances √† chaque ex√©cution du pipeline.

Dans la suite de ce tutoriel, nous allons voir comment utiliser le cache de GitLab CI pour stocker les d√©pendances des tests e2e entre les diff√©rents jobs de la pipeline.

Voici comment fonctionne le cache de GitLab CI :
- Lorsqu'un job est ex√©cut√© pour la premi√®re fois, le cache est vide.
- √Ä la fin de l'ex√©cution du job, les fichiers ou les r√©pertoires sp√©cifi√©s dans le cache sont stock√©s.
- Lorsque le m√™me job est ex√©cut√© √† nouveau, les fichiers ou les r√©pertoires stock√©s dans le cache sont t√©l√©charg√©s et utilis√©s.
- Cela permet de r√©duire le temps de construction en √©vitant de t√©l√©charger les d√©pendances √† chaque ex√©cution du job.
- Comment savoir si le cache doit √™tre mis √† jour ? GitLab CI utilise une cl√© pour identifier le cache. Si la cl√© change, le cache est consid√©r√© comme obsol√®te et doit √™tre mis √† jour.

## Configuration du cache de GitLab CI

Pour tenter d'acc√©l√©rer le temps d'ex√©cution de notre pipeline, nous pourrions tenter d'utiliser le cache de GitLab CI en mettant √† jour notre fichier `.gitlab-ci.yml`:

```yaml {4-5,10-15,29-33,51-58} showLineNumbers
stages:
  - test
  - e2e
variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"

api test:
  stage: test
  image: maven:3.9.9-amazoncorretto-21
  cache:
    key:
      files:
        - api/pom.xml
    paths:
      - $CI_PROJECT_DIR/.m2/repository
  script:
    - cd api
    - mvn clean test
  artifacts:
    paths:
      - api/target/reports/
      - api/target/site/
      - api/target/surefire-reports/

frontend test:
  stage: test
  image: node:20
  cache:
    key:
      files:
        - frontend/package-lock.json
    paths:
      - frontend/node_modules
  script:
    - cd frontend
    - npm install
    - npm run lint
    - npm run coverage
  artifacts:
    paths:
      - frontend/coverage/

e2e tests:
  stage: e2e
  image: mcr.microsoft.com/playwright:v1.50.0-jammy
  services:
    - docker:dind
  variables:
    DOCKER_HOST: tcp://docker:2375
  cache:
    key:
      files:
        - api/pom.xml
        - frontend/package-lock.json
    paths:
      - $CI_PROJECT_DIR/.m2/repository
      - frontend/node_modules
      - e2e/node_modules
  before_script:
    - apt update -y
    - wget https://download.oracle.com/java/21/latest/jdk-21_linux-x64_bin.deb
    - apt install ./jdk-21_linux-x64_bin.deb
    - apt install -y maven docker-compose-v2
    - docker compose -f api/docker-compose.yaml up --build -d
    - sleep 5
    - cd api
    - mvn clean spring-boot:run -Dspring-boot.run.profiles=test &
    - sleep 30
    - cd ../frontend
    - npm install
    - npm run dev &
    - sleep 30
    - cd ../e2e
    - npm install
  script:
    - npx playwright test
  artifacts:
    paths:
      - e2e/playwright-report/
      - e2e/test-results/
```

Voici quelques points importants √† noter dans cette configuration :
- Nous avons ajout√© une cl√© pour le cache de l'API et du frontend. Cette cl√© est bas√©e sur les fichiers de d√©pendances de l'API et du frontend. Si ces fichiers changent, le cache est consid√©r√© comme obsol√®te et doit √™tre mis √† jour.
- Il existe d'autres cl√©s possibles pour le cache, comme par exemple des variables d'environnement, des fichiers de configuration, etc. ;  par exemple, GitLab CI propose d'utiliser :
  - la variable **`$CI_COMMIT_REF_SLUG`** pour partager le cache entre des jobs de la m√™me branche  
  - la variable **`$CI_JOB_NAME`** pour partager le cache entre toutes les branches avec un cache unique par job.
- Pour pouvoir acc√©der aux d√©pendances de Maven, nous avons d√©fini la variable **`MAVEN_OPTS`** pour sp√©cifier le r√©pertoire local du d√©p√¥t Maven. Cela permet de stocker les d√©pendances de Maven dans le cache et de les r√©utiliser entre les diff√©rents jobs.

## Conclusion sur le cache de GitLab CI

Apr√®s configuration du cache, le temps d'ex√©cution de la pipeline n'est pas significativement plus court. 

Nous ne creuserons pas plus loin pour l'aspect cache de GitLab CI, car nous allons prochainement voir que la contain√©risation des applications peut nous aider √† r√©soudre plusieurs probl√®mes de la configuration actuelle du pipeline de CI.

Si vous souhaitez en savoir plus sur le cache de GitLab CI, vous pouvez consulter la documentation officielle de GitLab : https://docs.gitlab.com/ee/ci/caching/

Si n√©cessaire, vous pouvez trouver le code associ√© aux tests e2e ici : [e2e-test](https://github.com/e-vinci/cae-theory-demos/tree/main/e2e-tests).

## Probl√®me de configuration de l'API

Attention, si vous ex√©cutez l'API avec le profil de test localement, l'API est configur√©e pour utiliser **`docker`** comme h√¥te de la base de donn√©es dans le pipeline de CI. En effet, la configuration de l'API, au sein du fichier **`application-test.properties`**, est la suivante

```properties
spring.datasource.url=jdbc:postgresql://docker:5432/cae_db
```

Cette configuration fonctionne donc bien sur la pipeline de CI, mais pas si vous souhaitez ex√©cuter l'API localement et vous connecter √† votre DB localement.

Pour ex√©cuter l'API localement, vous pourriez :
- soit modifier le fichier **`application-test.properties`** pour utiliser **`localhost`** comme h√¥te de la base de donn√©es (`jdbc:postgresql://localhost:5432/cae_db`)
- soit cr√©er deux profils de tests diff√©rents, un pour la pipeline de CI et un pour l'ex√©cution locale de l'API. Vous pourriez par exemple cr√©er un fichier **`application-ci.properties`** pour la pipeline de CI et un fichier **`application-test.properties`** pour l'ex√©cution locale de l'API.
- soit utiliser une DB en ligne, pour ex√©cuter l'API localement. Ainsi l'URL vers la DB ne changera pas.
- soit ... il existe d'autres solutions, mais nous ne les d√©taillerons pas ici.

Nous allons voir comment √©viter ce genre de probl√®mes plus tard dans le cours, afin d'automatiser la gestion des URLs en fonction de l'environnement dans lequel nos applications sont ex√©cut√©es.